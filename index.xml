<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>当然我在扯淡</title>
    <link>http://wangerk.com/</link>
    <description>Recent content on 当然我在扯淡</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Feb 2019 20:55:53 +0800</lastBuildDate>
    
	<atom:link href="http://wangerk.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JAVA技术栈</title>
      <link>http://wangerk.com/blog-cn/java/to-be-top-javaer/</link>
      <pubDate>Mon, 18 Feb 2019 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/java/to-be-top-javaer/</guid>
      <description>目录： 《基础篇》JVM——JVM内存结构
《基础篇》JVM——Java内存模型
《基础篇》JVM——Java对象模型
《基础篇》JVM——HotSpot
《基础篇》JVM——垃圾回收
《基础篇》JVM——JVM参数及调优
《基础篇》JVM——常用Java命令
《基础篇》编译与反编译
《基础篇》Java基础知识——阅读源代码
《基础篇》Java基础知识——String相关
《基础篇》Java基础知识——Java中各种关键字
《基础篇》Java基础知识——自动拆装箱
《基础篇》Java基础知识——枚举
《基础篇》Java基础知识——反射
《基础篇》Java基础知识——序列化
《基础篇》Java基础知识——JMS
《基础篇》Java基础知识——泛型
《基础篇》Java基础知识——常用的Java工具库
《基础篇》Java基础知识——单元测试
《进阶篇》设计模式——设计模式合集
《高级篇》Java并发编程——锁
《高级篇》大数据知识—— Zookeeper合集
《高级篇》网络安全知识—— 解决webx的xss和csrf漏洞
《进阶篇》网络编程知识——常用协议
《扩展篇》分布式—— 分布式合集</description>
    </item>
    
    <item>
      <title>Mac OS X常见设置</title>
      <link>http://wangerk.com/blog-cn/2019/02/16/setting/</link>
      <pubDate>Sat, 16 Feb 2019 08:57:08 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2019/02/16/setting/</guid>
      <description>本小节知识点:  【理解】查看本机配置 【理解】系统开/关机 【理解】键盘设置 【理解】鼠标设置 【理解】网络设置  1.查看本机配置  点击屏幕左上角的黑色苹果   点击&amp;rdquo;关于本机&amp;rdquo;  2.系统开/关机  点击屏幕左上角的黑色苹果 选择&amp;rdquo;睡眠&amp;rdquo; or &amp;ldquo;重新启动&amp;rdquo; or &amp;ldquo;关机&amp;rdquo;   关机快捷键  command + option + control + △   3.键盘设置  点击屏幕左上角的黑色苹果 点击&amp;rdquo;系统偏好设置&amp;rdquo;   选择&amp;rdquo;键盘&amp;rdquo;   设置输入法  4.鼠标设置  查找鼠标   注意, 如果找不到需要关闭鼠标后重新打开   找到后点击继续   看到此图代表鼠标连接成功, 鼠标只需要配对一次, 以后系统会自动配对   注意默认情况下Mac系统不会像windows一样开启鼠标右键, 需要我们手动开启  5.网络设置  点击屏幕左上角的黑色苹果 点击&amp;rdquo;系统偏好设置&amp;rdquo;   选择&amp;rdquo;网络&amp;rdquo;   自动获取IP的方式上网   手动设置IP的方式上网  （本文建议零售价 ￥1，如果你觉得这篇文章有启发，可以点击这里付费)</description>
    </item>
    
    <item>
      <title>Java内存模型</title>
      <link>http://wangerk.com/basics/jvm/java-memory-model/</link>
      <pubDate>Fri, 15 Feb 2019 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/basics/jvm/java-memory-model/</guid>
      <description>本文是《JAVA技术栈系列文章》中的一篇，主要是关于JVM的一些介绍。
持续更新中
 Java内存模型 JVM内存结构 VS Java内存模型 VS Java对象模型(Hollis原创)
再有人问你Java内存模型是什么，就把这篇文章发给他。(Hollis原创)
内存模型是怎么解决缓存一致性问题的？(Hollis原创)
细说Java多线程之内存可见性（视频）（推荐）（如果嫌视频讲的慢，建议使用1.5倍速度观看）
JSR 133: JavaTM Memory Model and Thread Specification Revision（JMM英文官方文档）
Java内存模型FAQ
深入理解Java内存模型（一）——基础
深入理解Java内存模型（二）——重排序
深入理解Java内存模型（三）——顺序一致性
深入理解Java内存模型（四）——volatile
深入理解Java内存模型（五）——锁
深入理解Java内存模型（六）——final
深入理解Java内存模型（七）——总结
Java 理论与实践: 修复 Java 内存模型，第 2 部分（拓展阅读）</description>
    </item>
    
    <item>
      <title>Java内存模型，Java内存管理，Java堆和栈，垃圾回收</title>
      <link>http://wangerk.com/basics/jvm/jvm-memory-structure/</link>
      <pubDate>Fri, 15 Feb 2019 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/basics/jvm/jvm-memory-structure/</guid>
      <description>本文是《JAVA技术栈系列文章》中的一篇，主要是关于JVM的一些介绍。
持续更新中
 参考文章：
Java虚拟机的内存组成以及堆内存介绍
Java堆和栈看这篇就够
Java虚拟机的堆、栈、堆栈如何去理解？
Java 内存之方法区和运行时常量池
从0到1起步-跟我进入堆外内存的奇妙世界
JVM内存结构 VS Java内存模型 VS Java对象模型
参考书籍：《深入理解Java虚拟机》</description>
    </item>
    
    <item>
      <title>Java对象模型</title>
      <link>http://wangerk.com/basics/jvm/java-object-model/</link>
      <pubDate>Fri, 15 Feb 2019 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/basics/jvm/java-object-model/</guid>
      <description>本文是《JAVA技术栈系列文章》中的一篇，主要是关于JVM的一些介绍。
持续更新中
 JVM内存结构 VS Java内存模型 VS Java对象模型
深入理解多线程（二）—— Java的对象模型
深入理解多线程（三）—— Java的对象头</description>
    </item>
    
    <item>
      <title>博文的自愿付费方式</title>
      <link>http://wangerk.com/reward/pay-blog/</link>
      <pubDate>Fri, 15 Feb 2019 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/reward/pay-blog/</guid>
      <description>喜欢我的文章的人，可以自愿付费购买。你可以使用以下方式付款。
 支付宝：  微信：  PayPal：请点击[付款链接]  </description>
    </item>
    
    <item>
      <title>交易支付密码UI</title>
      <link>http://wangerk.com/blog-cn/2018/11/30/pay-password/</link>
      <pubDate>Fri, 30 Nov 2018 21:56:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/11/30/pay-password/</guid>
      <description>概念  一行代码实现  ///MARK:- 实例化一个密码 显示view -(void)addPasswordTextView:(CGRect)frame { _passwordTextView = [[SHPasswordTextView alloc]initWithFrame:frame count:6 margin:20 passwordFont:50 forType:SHPasswordTextTypeRectangle block:^(NSString * _Nonnull passwordStr) { NSLog(@&amp;quot;passwordStr == %@&amp;quot;,passwordStr); }]; //_passwordTextView.passwordSecureEntry = YES;//安全密码 [self.view addSubview:_passwordTextView]; }   选择样式  //提供5种样式展示 typedef NS_ENUM(NSInteger, SHPasswordTextType){ SHPasswordTextTypeNormal = 1 &amp;lt;&amp;lt; 0, /**默认 __*/ SHPasswordTextTypeAnimation_line = 1 &amp;lt;&amp;lt; 1, /**line动画__*/ SHPasswordTextTypeAnimation_font = 1 &amp;lt;&amp;lt; 2, /**字体动画__*/ SHPasswordTextTypeAnimation_lineAndFont = 1 &amp;lt;&amp;lt; 3, /**line和字体动画__*/ SHPasswordTextTypeRectangle = 1 &amp;lt;&amp;lt; 4 /**方块形☐☐*/ };  效果  矩形输入密码图:  安全输入密码图:  带有动画输入支付密码图:   下载demo https://gitee.</description>
    </item>
    
    <item>
      <title>AppStore申请加急审核及Apple联系方式大全</title>
      <link>http://wangerk.com/blog-cn/2018/11/19/appstore-accelerate/</link>
      <pubDate>Mon, 19 Nov 2018 15:24:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/11/19/appstore-accelerate/</guid>
      <description> 一、概念  1.直接提交申诉理由 (里面还有一起其他功能 如申请加急审核等.)
https://developer.apple.com/contact/app-store/?topic=appeal
2.开发问题, 貌似也可以问一些审核问题
https://developer.apple.com/contact/submit.PHP
3.苹果相关地区联系电话 ,中国区的为 4006 701 855
貌似审核周末继续 电话客户周末不上班
01085255770 苹果审核团队的电话
https://developer.apple.com/contact/phone.php
4.各地区 Apple 开发者支持电话号码:https://developer.apple.com/cn/contact/phone.php
太平洋标准时间上午11点&amp;ndash;晚上8点之间通过美国审核电话001 408 7830508
注意: 如果是座机要在前面多加一个0.
 二、实际操作  提交审核后进去下面链接申请加急审核
链接：https://developer.apple.com/appstore/contact/appreviewteam/index.html
在I would like to选择加急审核(默认选项)
图1:选择原因 图2:填写联系方式 图3:填写 APP 信息 图4:备注内容 注意: ⚠️这里可以填写中文，据说最好用英文，不过我自己写的是中文。
另外要注意的是理由一般是用户安全问题或者崩溃问题成功率会高一些
还有一点要注意的是，如果是崩溃问题，你最好写上操作步骤，让审核员去重现这个问题。
 </description>
    </item>
    
    <item>
      <title>同步锁原理合集</title>
      <link>http://wangerk.com/blog-cn/2018/11/14/lock/</link>
      <pubDate>Wed, 14 Nov 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/11/14/lock/</guid>
      <description>一、概念  我们在使用多线程的时候多个线程可能会访问同一块资源，这样就很容易引发数据错乱和数据安全等问题，这时候就需要我们保证每次只有一个线程访问这一块资源，锁 应运而生。
 不同锁的效率比较: 二、锁🔐锁 OSSpinLock (自旋锁)  自旋锁的实现原理比较简单，就是死循环。当a线程获得锁以后，b线程想要获取锁就需要等待a线程释放锁。在没有获得锁的期间，b线程会一直处于忙等的状态。如果a线程在临界区的执行时间过长，则b线程会消耗大量的cpu时间，不太划算。所以，自旋锁用在临界区执行时间比较短的环境性能会很高。
 注:苹果爸爸已经在iOS10.0以后废弃了这种锁机制,使用os_unfair_lock 替换, 顾名思义能够保证不同优先级的线程申请锁的时候不会发生优先级反转问题.
os_unfair_lock(自旋锁)  注:解决不同优先级的线程申请锁的时候不会发生优先级反转问题.不过相对于 OSSpinLock , os_unfair_lock性能方面减弱了许多.
 dispatch_semaphore (信号量)  注: dispatch_semaphore 其他两个功能
1.还可以起到阻塞线程的作用.
2.可以实现定时器功能,这里不做过多介绍.
 pthread_mutex(互斥锁)  pthread_mutex表示互斥锁，和信号量的实现原理类似，也是阻塞线程并进入睡眠，需要进行上下文切换。
 pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;amp;attr); pthread_mutexattr_settype(&amp;amp;attr, PTHREAD_MUTEX_NORMAL); pthread_mutex_t lock; pthread_mutex_init(&amp;amp;lock, &amp;amp;attr); //设置属性 pthread_mutex_lock(&amp;amp;lock); //上锁 //需要执行的代码 pthread_mutex_unlock(&amp;amp;lock); //解锁  NSLock(互斥锁、对象锁)  NSLock在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK。
 NSLock *lock = [NSLock new]; [lock lock]; //需要执行的代码 [lock unlock];  NSCondition(条件锁、对象锁)  NSCondition封装了一个互斥锁和条件变量。互斥锁保证线程安全，条件变量保证执行顺序。</description>
    </item>
    
    <item>
      <title>HOOK技术</title>
      <link>http://wangerk.com/blog-cn/2018/10/29/hook/</link>
      <pubDate>Mon, 29 Oct 2018 19:39:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/10/29/hook/</guid>
      <description> 一、概念  HOOK，中文译为“挂钩”或“钩子”。在iOS逆向中是指改变程序运行流程的一种技术。通过hook可以让别人的程序执行自己所写的代码。在逆向中经常使用这种技术。所以在学习过程中，我们重点要了解其原理，这样能够对恶意代码进行有效的防护。
 二、iOS中HOOK技术的几种方式  Method Swizzle
利用OC的Runtime特性，动态改变SEL（方法编号）和IMP（方法实现）的对应关系，达到OC方法调用流程改变的目的。主要用于OC方法。
 .
 fishhook
它是Facebook提供的一个动态修改链接mach-O文件的工具。利用MachO文件加载原理，通过修改懒加载和非懒加载两个表的指针达到C函数HOOK的目的。
 .
 Cydia Substrate Cydia Substrate 原名为 Mobile Substrate ，它的主要作用是针对OC方法、C函数以及函数地址进行HOOK操作。当然它并不是仅仅针对iOS而设计的，安卓一样可以用。官方地址：http://www.cydiasubstrate.com/
 三、原理图 四、代码 </description>
    </item>
    
    <item>
      <title>Xcode10升级项目报错解决方法</title>
      <link>http://wangerk.com/blog-cn/2018/10/10/xcode10/</link>
      <pubDate>Wed, 10 Oct 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/10/10/xcode10/</guid>
      <description>一、概念  Xcode10新特性
 图1: 图2: 二、问题directory not found for option  1.iOS &amp;ldquo;directory not found for option &amp;lsquo;-L/Users/&amp;hellip;/Pods/build/Debug-iphoneos/…“解决方案
 图3:编译错误  2.解决方案:
在Target－Build Settings中找到Search Paths－Library Search Paths，删除掉在警告中所示的该路径。
 图4:  3.注意: 先 clean 、编译 在运行。
 三、问题 script phase &amp;ldquo;[CP]Copy Pods Resources&amp;rdquo;  1.script phase &amp;ldquo;[CP]Copy Pods Resources&amp;rdquo; ~解决方法
 图5:编译错误  2.解决方案：
在Target－Build Phases — [CP]Copy Pods Resources — Output Files 下的 ${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH} 删除
 图6:删除 图7:  3.</description>
    </item>
    
    <item>
      <title>AppStore上传项目报隐私政策网址(URL)错误</title>
      <link>http://wangerk.com/blog-cn/2018/10/09/privacy/</link>
      <pubDate>Tue, 09 Oct 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/10/09/privacy/</guid>
      <description> 一、概念  问题：使用权限 [ com.apple.developer.in-app-payments] 的 App 必须为[Simplified Chinese]提供隐私政策网址(URL)。如果您的 App 不使用这些权限，请将它们从您的 App 中移除并上传新的二进制文件。
 二、问题展示 图1:  关键是：隐私政策网址(URL)！！！
在构建APP版本的时候需要你提供政策网址URL，而这个是非必填的；
当你app里面包含登录注册功能、支付功能等时。这个选项是必须的！！！
 三、解决方法：  这是我本app注册的协议的网址添加到 隐私政策网址(URL)下面并且保存即可.
 图2:  进入ituns Connect -&amp;gt;我的APP-&amp;gt;app信息
 图3: </description>
    </item>
    
    <item>
      <title>iOS连接外设的几种方式</title>
      <link>http://wangerk.com/blog-cn/2018/09/21/ios-connection/</link>
      <pubDate>Fri, 21 Sep 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/09/21/ios-connection/</guid>
      <description> 一、概念  一般iOS开发者做APP开发大部分时候都是通过Http(s)请求跟后台服务器打交道，做一些信息展示和用户交互。很少涉及到去跟外部硬件设备连接的开发。随着近年来车联网和物联网的兴起，智能家居和智能硬件的逐步火热，越来越多的app被开发出来，用来跟硬件设备进行来连接，获取硬件相关信息展示或者发送指令控制硬件来提供服务。故本文就针对iOS的app如何跟外部设备进行连接通信这个问题跟大家交流一下。本文原创，欢迎转载，转载请注明出处，如有不正确的地方恳请各位看官指正。
 可以分为三大类：  第一类是通过网络端口，建立Socket使用TCP/IP协议族进行通信，天然支持多通道，想要几个通道就建几个socket就行了。它主要有三种方式，第一种方式是Wi-Fi连接，优点是：简单，不需要集成MFi芯片，只要对应的硬件有无线网卡，然后手机和硬件连接到同一个局域网中就可以使用socket通过网络协议通信了。缺点也很明显：
（1)无线连接信号容易受到干扰，不太稳定，容易断开；
（2）如果硬件使用的场合没有公共wifi，就需要手机自建热点共享，硬件进行热点接入，操作步骤较多，对用户来说学习使用成本较高，并且热点共享要求手机本身的数据移动网络是稳定的，在没有移动数据网络信号的地方，热点无法建立。
 .
 需要先打开个人热点共享；
使用网络端口的第三种方式是NCM，就是把USB端口虚拟成标准的网络端口，然后手机和外设就能通过有线网络直连了，可以理解成手机和外设通过一跟网线连起来了，然后就可以用socket通过TCP，UDP进行通信了。它的优点是：有线连接，非常稳定，带宽足够；也不依赖移动网络信号；但是它的缺点就是：需要集成MFI芯片并进行MFI认证，有一定门槛。更变态的是这么好的一种方式，目前苹果只提到可以在它自己的CarPlay使用，其他硬件并没有说禁止或者允许使用。如果硬件使用NCM跟iOS系统的App通信，可能通过MFI认证是有风险的。
关于如何使用Socket进行TCP、UDP连接，推荐github上的开源项目CocoaAsyncSocket。
 .
 iOS App连接外部硬件的第二大类是EAP，全拼是External Accessory Protocol，外部设备协议。这个是苹果推荐使用的外设连接方式。需要外设集成MFI芯片进行MFI认证。手机端开发相对简单，只要集成 iOS系统提供的一个框架ExternalAccessory.framework，并且在info.plist中配置好协议字符串(Supported external accessory protocols），当iOS 设备通过USB线或者蓝牙连接到对应硬件时，iOS系统会把符合MFI认证要求的外设抽象成了一个流对象，App通过指定的协议字符串来创建一个EASession类的实例来访问到该流对象，就能通过NSInputStream和NSOutputStream跟硬件件进行通信了。它有两种模式，一种是叫EASession的模式，它带宽相对较低，但是允许同时通过多个协议字符串创建多个会话，也就是说直接支持多个通道；另外一种是Native Transport的模式，这种模式的优点是带宽足够大，理论值是100MB以上，但是不支持多通道，如果业务层需要支持多数据通道的话需要App自己进行通道的复用与拆分，并且Native Transport需要iPhone工作在USB host模式，硬件需要支持USB 模式切换。
关于如何使用EAP跟外部设备进行通信，可以参考苹果官方的Demo进行入门和学习。
 .
 第三大类就是BLE，低功耗蓝牙，是iOS7.0以后才支持的连接方式。它的优点是不需要集成MFI芯片做认证，功耗低，手机端开发也相对简单，集成iOS系统提供的CoreBluetooth.framework就行。缺点是：带宽很低，一般适合于只需要传输少量数据的场景。比如前两年非常火爆的各种所谓智能硬件，像智能水杯，智能体重计，运动手环等，都是采用这种连接方式。
关于如何使用BLE进行硬件连接，可以参考本人在github的一个小开源项目（https://github.com/luoxubin/BlueTooth4.0）。另外本人自己业余时间也做过一个BLE连接外设的App-裤宝（名字有创意吧，裤子里的宝贝，是跟我另外两个小伙伴一起做的创业项目，目前该项目黄了， 不过app还在线上，AppStore里搜索“裤宝”可以下载。
 .
 总结一下，图中带MFI字样的表示该连接方式需要硬件集成MFi芯片，做MFi认证。关于苹果的MFI认证，对iOS开发中来说其实是一个比较陌生并且繁琐的topic，原因如下：
 .
 （1）网上鲜有资料，Google基本上查不到。 因为MFi认证是由硬件生产商主导进行的，苹果首先对硬件生产商的实力（质量，信誉，生产规模）有很苛刻的要求，满足要求的才有进行MFI认证的资格。满足MFi认证资格要求的硬件生产商，提交了MFi产品计划后才能得到苹果MFi开发的官方文档，这个文档是带水印的，不允许外泄；
（2）MFi认证周期很长，过程也很复杂；
（3）苹果官方沟通渠道很窄，电话打不通，邮件回复不及时。
 </description>
    </item>
    
    <item>
      <title>监听应用程序被杀死</title>
      <link>http://wangerk.com/blog-cn/2018/09/16/observe-dead/</link>
      <pubDate>Sun, 16 Sep 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/09/16/observe-dead/</guid>
      <description> 监听应用进入后台 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(sh_comeHome:) name:@&amp;quot;UIApplicationDidEnterBackgroundNotification&amp;quot; object:nil];  (void)sh_comeHome:(UIApplication *)application { NSLog(@&amp;quot;进入后台&amp;quot;); }  监听应用程序被杀死 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillTerminate:) name:@&amp;quot;UIApplicationWillTerminateNotification&amp;quot; object:nil];  (void)applicationWillTerminate:(UIApplication *)application { NSLog(@&amp;quot;程序被杀死&amp;quot;); }  </description>
    </item>
    
    <item>
      <title>获取手机的IP地址(内网与外网)</title>
      <link>http://wangerk.com/blog-cn/2018/09/13/get-ip/</link>
      <pubDate>Thu, 13 Sep 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/09/13/get-ip/</guid>
      <description>获取内网IP #import &amp;lt;ifaddrs.h&amp;gt; #import &amp;lt;arpa/inet.h&amp;gt; #import &amp;lt;net/if.h&amp;gt; #define IOS_CELLULAR @&amp;quot;pdp_ip0&amp;quot; #define IOS_WIFI @&amp;quot;en0&amp;quot; #define IOS_VPN @&amp;quot;utun0&amp;quot; #define IP_ADDR_IPv4 @&amp;quot;ipv4&amp;quot; #define IP_ADDR_IPv6 @&amp;quot;ipv6&amp;quot; #pragma mark - 获取设备当前网络IP地址 + (NSString *)getIPAddress:(BOOL)preferIPv4 { NSArray *searchArray = preferIPv4 ? @[ IOS_VPN @&amp;quot;/&amp;quot; IP_ADDR_IPv4, IOS_VPN @&amp;quot;/&amp;quot; IP_ADDR_IPv6, IOS_WIFI @&amp;quot;/&amp;quot; IP_ADDR_IPv4, IOS_WIFI @&amp;quot;/&amp;quot; IP_ADDR_IPv6, IOS_CELLULAR @&amp;quot;/&amp;quot; IP_ADDR_IPv4, IOS_CELLULAR @&amp;quot;/&amp;quot; IP_ADDR_IPv6 ] : @[ IOS_VPN @&amp;quot;/&amp;quot; IP_ADDR_IPv6, IOS_VPN @&amp;quot;/&amp;quot; IP_ADDR_IPv4, IOS_WIFI @&amp;quot;/&amp;quot; IP_ADDR_IPv6, IOS_WIFI @&amp;quot;/&amp;quot; IP_ADDR_IPv4, IOS_CELLULAR @&amp;quot;/&amp;quot; IP_ADDR_IPv6, IOS_CELLULAR @&amp;quot;/&amp;quot; IP_ADDR_IPv4 ] ; NSDictionary *addresses = [self getIPAddresses]; NSLog(@&amp;quot;addresses: %@&amp;quot;, addresses); __block NSString *address; [searchArray enumerateObjectsUsingBlock:^(NSString *key, NSUInteger idx, BOOL *stop) { address = addresses[key]; //筛选出IP地址格式 if([self isValidatIP:address]) *stop = YES; } ]; return address ?</description>
    </item>
    
    <item>
      <title>项目架构模式(MVC、MVVM、MVCS、VIPER的选择)</title>
      <link>http://wangerk.com/blog-cn/2018/09/12/architecture/</link>
      <pubDate>Wed, 12 Sep 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/09/12/architecture/</guid>
      <description>一、概念 没有最好的架构，只有适合自己的业务的架构才是最好的架构，并且它是逐步地变强变大。
架构，又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。
二、iOS的系统架构分为四个层次： 核心操作系统层（Core OS layer）、核心服务层（Core Services layer）、媒体层（Media layer）和可触摸层（Cocoa Touch layer）。下面是IOS系统结构图。 1、Core OS是位于iOS系统架构最下面的一层是核心操作系统层，它包括内存管理、文件系统、电源管理以及一些其他的操作系统任务。它可以直接和硬件设备进行交互。作为app开发者不需要与这一层打交道。
 2、Core Services是核心服务层，可以通过它来访问iOS的一些服务。
 3、Media是媒体层，通过它我们可以在应用程序中使用各种媒体文件，进行音频与视频的录制，图形的绘制，以及制作基础的动画效果。  4、Cocoa Touch是可触摸层，这一层为我们的应用程序开发提供了各种有用的框架，并且大部分与用户界面有关，本质上来说它负责用户在iOS设备上的触摸交互操作。
iOS是基于UNIX内核，android是基于Linux内核，iOS和android作为两款优秀的手机操作系统，他们有共性有区别，下面分享一张android系统架构图： 三、常见的分层架构 有三层架构：视图层、业务层、数据层。
也有四层架构：视图层、业务层、网络层、本地数据层。
这里说三层、四层，跟TCP/IP所谓的五层或者七层不是同一种概念。再具体说就是：你的架构在逻辑上设计的是几层那就是几层，具体每一层的名称和作用，没有特定的规范, 这主要是针对模块分类而言的。
 1.视图层设计方案
 2.网络层设计方案  3.本地持久化方案
 4.动态部署方案
上面这四大点，稍微细说一下就是：
 页面如何组织，才能尽可能降低业务方代码的耦合度？尽可能降低业务方开发界面的复杂度，提高他们的效率？ 如何让业务开发工程师方便安全地调用网络API？然后尽可能保证用户在各种网络环境下都能有良好的体验？ 当数据有在本地存取的需求的时候，如何能够保证数据在本地的合理安排？如何尽可能地减小性能消耗？ iOS应用有审核周期，如何能够通过不发版本的方式展示新的内容给用户？如何修复紧急bug？  四、视图层设计方案 一般来说，一个不够好的View层架构，主要原因有以下五种：
 1.代码混乱不规范
 2.过多继承导致的复杂依赖关系
 3.模块化程度不够高，组件粒度不够细
 4.横向依赖
 5.架构设计失去传承
View层的代码结构规范 制定代码规范严格来讲不属于View层架构的事情，但它对View层架构未来的影响会比较大，也是属于架构师在设计View层架构时需要考虑的事情。制定View层规范的重要性在于：
 1.提高业务方View层的可读性可维护性
 2.防止业务代码对架构产生腐蚀  3.确保传承
 4.保持架构发展的方向不轻易被不合理的意见所左右
五、架构模式(MVC、MVVM、MVCS、VIPER的选择) MVC
 任务均摊–View和Model确实是分开的，但是View和Controller却是紧密耦合的 可测试性–由于糟糕的分散性，只能对Model进行测试 易用性–与其他几种模式相比最小的代码量。熟悉的人很多，因而即使对于经验不那么丰富的开发者来讲维护起来也较为容易。 MVVM</description>
    </item>
    
    <item>
      <title>让UIView和UIButton的左上角和右上角为圆角</title>
      <link>http://wangerk.com/blog-cn/2018/08/26/border-radius/</link>
      <pubDate>Sun, 26 Aug 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/08/26/border-radius/</guid>
      <description>UIView 的左上角和右上角为圆角 -(UIView *)platFormRadiusView{ if (!_platFormRadiusView) { _platFormRadiusView = [[UIView alloc] init]; _platFormRadiusView.backgroundColor = [UIColor redColor]; _platFormRadiusView.frame = CGRectMake(0, 100,self.view.frame.size.width , 200); [self.view addSubview:_platFormRadiusView]; // 左上和右上为圆角 UIBezierPath *cornerRadiusPath = [UIBezierPath bezierPathWithRoundedRect:_platFormRadiusView.bounds byRoundingCorners:UIRectCornerTopRight | UIRectCornerTopLeft cornerRadii:CGSizeMake(15, 15)]; CAShapeLayer *cornerRadiusLayer = [ [CAShapeLayer alloc ] init]; cornerRadiusLayer.frame = _platFormRadiusView.bounds; cornerRadiusLayer.path = cornerRadiusPath.CGPath; _platFormRadiusView.layer.mask = cornerRadiusLayer; } return _platFormRadiusView; }  UIButton 的左上角和右上角为圆角 -(void)platFormRadiusButton{ UIButton *shButton = [UIButton buttonWithType:UIButtonTypeCustom]; shButton.frame = CGRectMake(0, 100, self.</description>
    </item>
    
    <item>
      <title>返回到任意界面(控制器)</title>
      <link>http://wangerk.com/blog-cn/2018/08/25/to-any-controller/</link>
      <pubDate>Sat, 25 Aug 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/08/25/to-any-controller/</guid>
      <description>方式一:根据指定的类名返回  for (UIViewController *controller in self.navigationController.viewControllers) { if ([controller isKindOfClass:[要返回的类名 class]]) { [self.navigationController popToViewController:controller animated:YES]; } }  方式二:根据栈的索引返回  NSArray *temArray = self.navigationController.viewControllers; [self.navigationController popToViewController:[temArray objectAtIndex:1] animated:YES]; 打印: Printing description of temArray: &amp;lt;__NSArrayI 0x1054a20c0&amp;gt;( &amp;lt;MeasureVC: 0x10183f800&amp;gt;, &amp;lt;SHAskDoctorViewController: 0x104791c40&amp;gt;, &amp;lt;SHChooseDoctorViewController: 0x1047b8170&amp;gt;, &amp;lt;SHDoctorVisitsViewController: 0x10af7d640&amp;gt;, &amp;lt;SHMicroLetterPayViewController: 0x10bf26430&amp;gt; )  方式三:类似方式一,推荐使用方式一  NSArray *temArray = self.navigationController.viewControllers; SHSpecialHistoryViewController *test = [[SHSpecialHistoryViewController alloc] init]; for(UIViewController *temVC in temArray){ if([temVC isKindOfClass:[test class]]) { [self.navigationController popToViewController:temVC animated:YES]; } }  方式四:修改rootViewController  AppDelegate *appDelegate = (AppDelegate *)[UIApplication sharedApplication].</description>
    </item>
    
    <item>
      <title>weakSelf与宏</title>
      <link>http://wangerk.com/blog-cn/2018/02/15/weak-self/</link>
      <pubDate>Thu, 15 Feb 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/02/15/weak-self/</guid>
      <description>1.防止如block的循环引用时，会使用__weak关键字做如下定义：
__weak typeof(self) weakSelf = self;
使用: [weakSelf addSubViews];
2.写成宏的方法:
#define WeakSelf __weak typeof(self) weakSelf = self;
使用: [WeakSelf addSubViews];
3.宏的优化,让部分的变量也可以使用weak
#define WeakObj(o) __weak typeof(o) o##Weak = o;
使用: WeakObj(self)
[selfWeak addSubViews];
4.利用了@autoreleasepool{}这个系统的关键字来实现,添加了@符号在前面,看起来更原生
#define WeakObj(o) autoreleasepool{} __weak typeof(o) o##Weak = o;
使用:
@WeakObj(self)
[selfWeak addSubViews];
5.利用了try{}@finally{}这个系统的关键字来实现,添加了@符号在前面,看起来更原生
#define WeakObj(o) try{}@finally{} __weak typeof(o) o##Weak = o;
使用:
@WeakObj(self)
[selfWeak addSubViews];
注意:
1.这部分空的@try或者空的@autoreleasepool会在编译时被优化掉，不必担心性能问题。
2.实际开发中常用3条和5条的定义方式</description>
    </item>
    
    <item>
      <title>OC中分类Category实现原理</title>
      <link>http://wangerk.com/blog-cn/2018/01/31/category/</link>
      <pubDate>Wed, 31 Jan 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/01/31/category/</guid>
      <description>一、概念 1.前言
category是Objective-C 2.0之后添加的语言特性，
category的主要作用是为已经存在的类添加方法。
2.设计思想
Objective-C 中的 Category 就是对装饰模式的一种具体实现。它的主要作用是在不改变原有类的前提下，动态地给这个类添加一些方法。
在 Objective-C 中的具体体现为：实例（类）方法、属性和协议。
二、使用场景 1.给现有的类添加方法；
2.将一个类的实现拆分成多个独立的源文件;
好处:
 a)可以减少单个文件的体积
 b)可以把不同的功能组织到不同的category里
 c)可以由多个开发者共同完成一个类
 d)可以按需加载想要的category 等等。
3.声明私有的方法。
三、实现原理 1.我们不主动引入 Category 的头文件，Category 中的方法都会被添加进主类中。我们可以通过 - performSelector: 等方式 对 Category 中的相应方法进行调用
 a)将 Category 和它的主类（或元类）注册到哈希表中；
 b)如果主类（或元类）已实现，那么重建它的方法列表。
2.在这里分了两种情况进行处理：Category 中的实例方法和属性被整合到主类中；而类方法则被整合到元类中。另外，对协议的处理比较特殊，Category 中的协议被同时整合到了主类和元类中。
3.注意到，不管是哪种情况，最终都是通过调用 staticvoid remethodizeClass(Class cls) 函数来重新整理类的数据的。
四、category结构体 1.所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t.
2.category结构体的定义：
struct category_t { const char *name; //类的名字（name） classref_t cls; //类（cls） struct method_list_t *instanceMethods; //category中所有给类添加的实例方法的列表（instanceMethods） struct method_list_t *classMethods; //category中所有添加的类方法的列表（classMethods） struct protocol_list_t *protocols; //category实现的所有协议的列表（protocols） struct property_list_t *instanceProperties; //category中添加的所有属性（instanceProperties） };   3.</description>
    </item>
    
    <item>
      <title>组件化</title>
      <link>http://wangerk.com/blog-cn/2018/01/15/components/</link>
      <pubDate>Mon, 15 Jan 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/01/15/components/</guid>
      <description>一、概念 1.为什么要组件化？
 * 组件和组件之间没有明确的约束；
 * 组件单独开发、单独测试，不能揉入主项目中开发，测试也可以针对性的测试；
 * 解决人多（更好的协作）、需求多（更好的功能模块划分）的问题；
 * 解决项目模块间的代码耦合问题；（坚决抵制业务组件间代码直接引用）
2.如何拆分组件？
 基础功能组件：（类似于性能统计、Networking、Patch、网络诊断等）
 按功能分库，不涉及产品业务需求，跟库Library类似
 通过良好的接口拱上层业务组件调用；
 不写入产品定制逻辑，通过扩展接口完成定制；
 基础UI组件：（例如下拉刷新组件、iCausel类似的组件）
 产品内通用UI组件；（各个业务模块依赖使用，但需要保持好定制扩展的设计）
 公共通用UI组件；（不涉及具体产品的视觉设计， 目前较少）
 产品业务组件：（例如圈子、1元购、登录、客服MM等）
 业务功能间相对独立，相互间没有Model共享的依赖；
 业务之间的页面调用只能通过UIBus进行跳转；
 业务之间的逻辑Action调用只能通过服务提供；
二、方案 方案一、url-block
 这是蘑菇街中应用的一种页面间调用的方式，通过在启动时注册组件提供的服务，把调用组件使用的url和组件提供的服务block对应起来，保存到内存中。在使用组件的服务时，通过url找到对应的block，然后获取服务
下图是url-block的架构图： 方案二、target-action
 casa的方案是通过给组件包装一层wrapper来给外界提供服务，然后调用者通过依赖中间件来使用服务；其中，中间件是通过runtime来调用组件的服务，是真正意义上的解耦，也是该方案最核心的地方。具体实施过程是给组件封装一层target对象来对外提供服务，不会对原来组件造成入侵；然后，通过实现中间件的category来提供服务给调用者，这样使用者只需要依赖中间件，而组件则不需要依赖中间件。
下图是casa的组件化方案架构图： 方案三、protocol-class
针对方案一的问题，蘑菇街又提出了另一种组件化的方案，就是通过protocol定义服务接口，组件通过实现该接口来提供接口定义的服务，具体实现就是把protocol和class做一个映射，同时在内存中保存一张映射表，使用的时候，就通过protocol找到对应的class来获取需要的服务。</description>
    </item>
    
    <item>
      <title>SEL存储位置、原理</title>
      <link>http://wangerk.com/blog-cn/2018/01/14/sel/</link>
      <pubDate>Sun, 14 Jan 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/01/14/sel/</guid>
      <description>一、概念 1.SEL类型是OC中用来定义方法的关键字，和其他语言不同的是SEL类型虽然是方法定义，但却不从属于任何类实例，其值是通过@selector进行计算，可以把它当做一个函数指针来使用，当然它实际上并不是一个函数指针，而是const char*。
2.SEL类型可以在编译时通过@selector()直接创建，也可以用NSSelectorFromString()函数创建，这个函数允许你通过名字调用方法。
 例如：
 [object performSelector:@selector(doSomething)]];
 它和如下代码等价：[object doSomething];
3.各种语言都有传递函数的方法:C语言使用函数指针，C++中有函数引用，OC使用选择器selector和block。
二、方法的存储位置 @interface Person：NSObject +(void)test1； -(void)test2; @end Person *person = [[Person alloc]init];  在内存中如下： 2.在内存中每个类的方法都存储在类对象中，
 每个方法都有一个与之对应的SEL类型的数据，
 根据一个SEL数据就可以找到对应的方法地址，进而调用方法。
 SEL类型的定义：typedef struct objc_selector *SEL.
 *************************
 SEL对象的创建
 SEL s1 = @selector（test1）；
 SEL s2 = NSSelectorFromString（@“test1”）
 注意:SEL就是对方法的一种包装。</description>
    </item>
    
    <item>
      <title>self,super底层实现原理</title>
      <link>http://wangerk.com/blog-cn/2018/01/04/self-super/</link>
      <pubDate>Thu, 04 Jan 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/01/04/self-super/</guid>
      <description>一、 self和super区别
 1. self是类，super是预编译指令
 2. self调用自己方法，super调用父类方法
 3.【self class】和【super class】输出是一样的
二、self和super底层实现原理
 1、当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；
 当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法。
 2、当使用 self 调用时，会使用 objc_msgSend 函数：id objc_msgSend(id theReceiver,SEL theSelector, &amp;hellip;)。
 第一个参数是消息接收者，
 第二个参数是调用的具体类方法的 selector，
 第三个参数是 selector 方法的可变参数。
 2、2例子:[self setAge:]
 a:编译器会替换成调用 objc_msgSend 的函数调用，
 b:其中 theReceiver 是 self，theSelector 是@selector(setAge:)，这个 selector 是从当前 self 的 class 的方法列表开始找的 setAge，
 c:当找到后把对应的 selector 传递过去。
 3、当使用 super 调用时，会使用 objc_msgSendSuper 函数：id objc_msgSendSuper(struct objc_super *super,SEL op, &amp;hellip;)</description>
    </item>
    
    <item>
      <title>Runtime动态添加方法</title>
      <link>http://wangerk.com/blog-cn/2018/01/01/dynamic-add-method/</link>
      <pubDate>Mon, 01 Jan 2018 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2018/01/01/dynamic-add-method/</guid>
      <description>一、概念  1.动态添加方法
开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。
 .
 2.效果图:
 二、代码实现  1.控制器代码:
 #pragma mark -动态添加方法 #pragma mark ------------------ - (void)addMethods{ SHPerson *person = [[SHPerson alloc] init]; //默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。 //动态添加方法就不会报错 [person performSelector:@selector(eat)]; } - (void)addMethods2{ SHPerson2 *person = [[SHPerson2 alloc] init]; [person performSelector:@selector(writeCode:) withObject:@100]; }   2.分类代码
 #import &amp;quot;SHPerson2.h&amp;quot; #import &amp;lt;objc/message.h&amp;gt; @implementation SHPerson2 void effect(id self, SEL _cmd, NSNumber *meter) { NSLog(@&amp;quot; effect ==&amp;gt; %@&amp;quot;, meter); } + (BOOL)resolveInstanceMethod:(SEL)sel{ if (sel == NSSelectorFromString(@&amp;quot;writeCode:&amp;quot;)) { // class: 给哪个类添加方法 // SEL: 添加哪个方法 // IMP: 方法实现 =&amp;gt; 函数 =&amp;gt; 函数入口 =&amp;gt; 函数名 // type: 方法类型：void用v来表示，id参数用@来表示，SEL用:来表示 //aaa不会生成方法列表 class_addMethod(self, sel, (IMP) effect, &amp;quot;v@:@&amp;quot;); return YES; } return [super resolveInstanceMethod:sel]; } @end   3.</description>
    </item>
    
    <item>
      <title>Runtime动态添加属性</title>
      <link>http://wangerk.com/blog-cn/2017/12/30/dynamic-add-prop/</link>
      <pubDate>Sat, 30 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/30/dynamic-add-prop/</guid>
      <description>一、概念   1.runtime：动态添加属性:什么时候需要动态添加属性;
2.开发场景：给系统的类添加属性的时候,可以使用runtime动态添加属性方法;
3.本质:动态添加属性,就是让某个属性与对象产生关联。runtime一般都是针对系统的类;
4.在分类中利用runtime动态添加属性;
 二、代码实现  1.控制器代码:
 // Created by on 2017/12/29. // Copyright © 2017年 wangerk. All rights reserved. // #import &amp;quot;SHAddAttributesViewController.h&amp;quot; @interface SHAddAttributesViewController () @end @implementation SHAddAttributesViewController - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor orangeColor]; //给系统NSObject类动态添加属性name NSObject *objc = [[NSObject alloc] init]; objc.name = @&amp;quot;123&amp;quot;; NSLog(@&amp;quot;objc.name = %@&amp;quot;,objc.name); } @end   2.分类代码
 // Created by on 2017/12/29. // Copyright © 2017年 wangerk.</description>
    </item>
    
    <item>
      <title>ENABLE_BITCODE报错</title>
      <link>http://wangerk.com/blog-cn/2017/12/29/bitcode-errror/</link>
      <pubDate>Fri, 29 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/29/bitcode-errror/</guid>
      <description>一、概念 报错图显示: 问题分析：
从上述的错误中应该可以看出，这是因为一个第三方的库不兼容，我的工程中开启了 ENABLE_BITCODE （应该是升级之后自动转换的），而这个第三方的库在编译的时候没有 enable bitcode，所以导致上诉问题。
二、解决方法： 方法一 :
一种就是换成 enable bitcode 的第三方库，再有一种就是将工程的 ENABLE_BITCODE 设置为 false 就可以了。
不太方便换库 ,不建议换库;
方法二:</description>
    </item>
    
    <item>
      <title>__nullable和__nonnull区别</title>
      <link>http://wangerk.com/blog-cn/2017/12/27/nullable-nonnull/</link>
      <pubDate>Wed, 27 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/27/nullable-nonnull/</guid>
      <description>一、概念  两个新的类型修饰： __nullable 和 __nonnull 。从字面上我们可知， __nullable 表示对象可以是 NULL 或 nil，而 __nonnull 表示对象不应该为空。
 当我们不遵循这一规则时，编译器就会给出警告。在 Xcode 7 中，为了避免与第三方库潜在的冲突，苹果把 __nonnull/__nullable改成 _Nonnull/_Nullable 。再加上苹果同样支持了没有下划线的写法 nonnull/nullable ，于是就造成现在有三种写法这样混乱的局面。
 但是这三种写法本质上都是互通的，只是放的位置不同，
二、声明属性 方法返回值修饰：
 - (nullable NSString*)method;
 - (NSString* __nullable)method;
 - (NSString* _Nullable)method;
声明属性的修饰：
 @property(nonatomic,copy,nullable)NSString *aString;
 @property(nonatomic,copy)NSString* __nullable aString;
 @property(nonatomic,copy)NSString* _Nullable aString;
方法参数修饰：
 - (void)methodWithString:(nullable NSString*)aString;
 - (void)methodWithString:(NSString* _Nullable)aString;
 - (void)methodWithString:(NSString* __nullable)aString;
三、总结 而对于 双指针类型对象 、 Block 的返回值 、 Block 的参数 等，这时候就不能用 nonnull/nullable 修饰，只能用带下划线的 __nonnull/__nullable 或者 _Nonnull/_Nullable ：</description>
    </item>
    
    <item>
      <title>编译时和运行时</title>
      <link>http://wangerk.com/blog-cn/2017/12/26/compile-runtime/</link>
      <pubDate>Tue, 26 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/26/compile-runtime/</guid>
      <description>一、概念 编译时
编译时:就是正在编译的时候.其实编译时就是简单的作一些翻译工作,
编译: 就是编译器帮你把源代码翻译成机器能识别的代码.(当然只是一般意义上这么说,实际上可能只是翻译成某个中间状态的语言.比如Java只有JVM识别的字节码,C#中只有CLR能识别的MSIL.另外还有啥链接器.汇编器.为了了便于理解我们可以统称为编译器)
运行时
运行时就是代码跑起来了.被装载到内存中去了.(你的代码保存在磁盘上没装入内存之前是个死家伙.只有跑到内存中才变成活的).而运行时类型检查就与前面讲的编译时类型检查(或者静态类型检查)不一样.不是简单的扫描代码.而是在内存中做些操作,做些判断.
二、例子说明：  1.string在编译时和运行时分别时什么类型的对象?
 NSString*string = (NSString *)[[NSData alloc] init];
 编译时是NSString的类型;
 运行时是NSData类型的对象
 2.例子
 Father fa;
 Son so;
 fa = so;
 fa.Fun(); //在编译时,实际上是把Fun当作Father类中的Fun看待.
 //但在运行时实际上这里的Fun是调用的Son中的函数Fun.所以不做运行时类型检查是没法确定的啊.</description>
    </item>
    
    <item>
      <title>copy修饰NSMutableArray的错误</title>
      <link>http://wangerk.com/blog-cn/2017/12/24/copy-nsmutable/</link>
      <pubDate>Sun, 24 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/24/copy-nsmutable/</guid>
      <description>1.错误方法一
@property (copy) NSMutableArray * arrayCopy;//声明 copy
NSMutableArray *arrayStrong =[NSMutableArrayarray];//初始化
 arrayCopy = arrayStrong;
2.错误方法二
 @property (strong) NSMutableArray *arrayCopy;/声明 strong
 NSMutableArray *arrayStrong = [NSMutableArray array];/初始化
 arrayCopy = [arrayStrong copy];
 注意:错误方法一 和 错误方法二是相同的,等价的;
3.结果
 所以你的arrayCopy根本就是一个NSArray，所以报了
 -[__NSArray0 removeAllObjects]: unrecognized selector sent to instance 0x14e14970
 未找到实例方法的错误。因为NSArray没有removeAllObjects方法。
4.正确的写法应该是不用copy属性
 @property (strong) NSMutableArray * arrayCopy;
 NSMutableArray* arrayStrong = [NSMutableArray array];
 arrayCopy = [arrayStrong mutableCopy];
 这里的arrayStrong可以是NSMutableArray也可以是NSArray；</description>
    </item>
    
    <item>
      <title>避免循环引用</title>
      <link>http://wangerk.com/blog-cn/2017/12/22/avoid-recycle-reference/</link>
      <pubDate>Fri, 22 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/22/avoid-recycle-reference/</guid>
      <description>循环引用:指的是多个对象相互引用时，使得引用形成一个环形，导致外部无法真正是否掉这块环形内存。其实有点类似死锁。
 其实循环引用就是说我们的强引用形成了闭环，还会有很多自己写的代码中会出现，平时还是要注意写法。当然xcode的instruments也能帮助到大家排除一些这样类似的内存问题。 例子：A-&amp;gt;B-&amp;gt;C-&amp;gt;&amp;hellip;.-&amp;gt;X-&amp;gt;B -&amp;gt;表示强引用，这样的B的引用计数就是2，假如A被系统释放了，理论上A会自动减小A所引用的资源，就是B，那么这时候B的引用计数就变成了1，所有B无法被释放，然而A已经被释放了，所有B的内存部分就肯定无法再释放再重新利用这部分内存空间了，导致内存泄漏。
 1.NSTimer
 创建使用NSTimer的时候，NSTimer会默认对当前self有个强引用，所有在self使用完成打算是否的时候，一定要先使用NSTimer的invalidate来停止是否时间控制对self的引用
 [_timer invalidate];
 2.Block
 Block也是比较常见的循环引用问题，在Block中使用了self容易出现循环引用，因此很多人在使用block的时候，加入里面有用到self的操作都会声明一个__weak来修饰self。其实便不是这样的，不是所有使用了Block都会出现Self循环引用问题，只有self拥有Block的强引用才会出现这种情况。
 所以一般在函数中临时使用Block是不会出现循环应用的，因为这时候Block引用是属于栈的。当栈上的block释放后，block中对self的引用计数也会减掉
 当然不一定要Self对Block有直接的引用才会出现，假如self的变量B，B中有个Block变量，就容易出现这种情况，好的是在block出现循环引用的，xcode7会出现警告提示（之前版本不确定）。
 3.delegate
 Delegate是ios中开发中最常遇到的循环引用，一般在声明delegate的时候都要使用弱引用weak或者assign
 @property (nonatomic, weak, nullable) id  delegate;
 当然怎么选择使用assign还是weak，MRC的话只能用assign，在ARC的情况下最好使用weak，因为weak修饰的变量在是否后自动为指向nil，防止不安全的野指针存在</description>
    </item>
    
    <item>
      <title>多线程操作数组</title>
      <link>http://wangerk.com/blog-cn/2017/12/21/multi-thread-op-array/</link>
      <pubDate>Thu, 21 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/21/multi-thread-op-array/</guid>
      <description>一、概念 1.含义:
@synchronized(self) {
}
//这个其实就是 一个加锁。如果self 其他线程访问，则会阻塞。这样做一般是用来对单
2.重写构造方法  @interface SHSafetyArray : NSObject
 {
 @private
 NSMutableArray *_mutableArray; //声明数组
 }
 //遍历加锁
 - (void) multi:(void (^)(NSObject*)) multipass;
 @end
 @implementation SHSafetyArray
 //初始化
 - (id)init {  if (self = [super init]) {
 _mutableArray = [[NSMutableArrayalloc]init];
 }
 return self;
 }
//遍历加锁
 - (void)multi:(void (^)(NSObject *)) multipass {</description>
    </item>
    
    <item>
      <title>OC的运行时特性(动态)</title>
      <link>http://wangerk.com/blog-cn/2017/12/17/runtime-feature/</link>
      <pubDate>Sun, 17 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/17/runtime-feature/</guid>
      <description>一、概念: 因为运行时 runtime 是 必须到运行时(run time)才会做一些事情;
所以OC的动态特性表现为了三个方面：动态类型、动态绑定、动态加载;
动态：主要是将数据类型的确定由编译时，推迟到了运行时。之所以叫做动态，
二、iOS OC动态运行时~动态类型  1.动态类型,就是id类型。
 2.动态类型是跟静态类型相对的。像内置的明确的基本类型都属于静态类型(int、NSString等)。
 3.静态类型 在编译的时候就能被识别出来。所以，若程序发生了类型不对应，编译器就会发出警告。
 4.动态类型 就编译器编译的时候是不能被识别的，要等到运行时(run time)，即程序运行的时候才会根据语境来识别。
 id obj = someInstance;
 if ([obj isKindOfClass:someClass]) {
 someClass *classSpecifiedInstance = (someClass *)obj;
 }
 注意: 静态类型就在编译时;动态类型是在运行时;
三、iOS OC动态运行时~动态绑定  在OC中，没有函数的概念，我们叫“消息机制”，函数调用就是给对象发送一条消息。这时，动态绑定的特性就来了。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去。这就是动态绑定，
 1.动态绑定只需记住关键词@selector/SEL即可。静态的，不能改变。要实现他就必须用SEL变量绑定一个方法。最终形成的这个SEL变量就代表一个方法的引用。
 2.这里要注意 一点：SEL并不是C里面的函数指针，虽然很像，但真心不是函数指针。SEL变量只是一个整数，他是该方法的ID，@selector()就是取类方法的编号。
 3. 以前的函数调用，是根据函数名，也就是 字符串去查找函数体。但现在，我们是根据一个ID整数来查找方法，整数的查找字自然要比字符串的查找快得多！所以，动态绑定的特定不仅方便，而且效率更 高。
 4.由于OC的动态特性，在OC中其实很少提及“函数”的概念，传统的函数一般在编译时就已经把参数信息和函数实现打包到编译后的源码中了，而在OC中最常使 用的是消息机制。调用一个实例的方法，所做的是向该实例的指针发送消息，实例在收到消息后，从自身的实现中寻找响应这条消息的方法
 5.补充:对于其他一些静态语言，比如 c++,一般在编译的时候就已经将将要调用的函数的函数签名都告诉编译器了。
四、iOS OC动态运行时~动态加载  根据需求加载所需要的资源，这点很容易理解，对于iOS开发来说，基本就是根据不同的机型做适配。最经典的例子就是在Retina设备上加载@2x的图片，而在老一些的普通屏设备上加载原图。
 开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。</description>
    </item>
    
    <item>
      <title>@property修饰符</title>
      <link>http://wangerk.com/blog-cn/2017/12/16/property-modifier/</link>
      <pubDate>Sat, 16 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/16/property-modifier/</guid>
      <description>1.strong类似于retain，weak类似于assign
2.原子性修饰符:atomic | nonatomic atomic:表示是线程安全的。
nonatomic:表示是非线程安全的，使用此属性性能会提高一些。
系统默认是atomic
3.getter和setter修饰符 @property(getter = getMethodName, setter = setMethodName) Object *obj;
这两个属性修饰符用于设置自定义生成的getter和setter方法名，使用之后将不再使用系统默认的setter和getter方法名。
4.getter方法。 readonly:表明这个属性只能读不能写，系统只为我们创建一个getter方法，不会创建setter方法
5.setter相关修饰符：assign | retain | copy setter相关的修饰符表明setter方法应该如何实现
6.copy:主要用在NSString类型，表示复制内容。 系统默认属性是assign。retain是指针的复制，copy是内容的复制
7.读写性修饰符：readwrite | readonly readwrite:表明这个属性是可读可写的，系统为我们创建这个属性的setter和getter方法。
8.readonly:表明这个属性只能读不能写， 系统只为我们创建一个getter方法，不会创建setter方法
9.assign:表示直接赋值， 用于基本数据类型(NSInteger和CGFloat)和C数据类型(如int, float, double, char等)另外还有id类型，这个修饰符不会牵涉到内存管理。但是如果是对象类型，使用此修饰符则可能会导致内存泄漏或EXC_BAD_ACCESS错误
assign：用于非指针变量。用于基础数据类型(如NSInteger, CGFloat)和C数据类型(int, float, double, char等), 另外还有id类型。
记住：前面不需要加＊的就用assign
10.retain:针对对象类型进行内存管理。 如果对基本数据类型使用，则Xcode会直接报错。当给对象类型使用此修饰符时，setter方法会先将旧的对象属性release掉，再对新的对象进行一次赋值并进行一次retain操作
retain：用于指针变量。一般用于字符串(NSString, NSMutableString), 数组(NSMutableArray, NSArray),字典对象，视图对象(UIView)，控制器对象(UIViewController)等</description>
    </item>
    
    <item>
      <title>Xcode 9 Safe Area 报错解决</title>
      <link>http://wangerk.com/blog-cn/2017/12/14/safe-area/</link>
      <pubDate>Thu, 14 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/14/safe-area/</guid>
      <description>1.在XIB开发时会报这样的错误
Xcode9 Safe Area Layout Guide Before iOS9.0
苹果在iOS7中引入的Top Layout Guide和Bottom Layout Guide,这些布局指南在iOS 11中被弃用，取而代之的是Safe Area Layout Guide.
针对新特性，解决方案如下 :
图1: 图2: 图3: </description>
    </item>
    
    <item>
      <title>KVC实现原理</title>
      <link>http://wangerk.com/blog-cn/2017/12/13/set-value-for-key/</link>
      <pubDate>Wed, 13 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/13/set-value-for-key/</guid>
      <description>- (void)setValue:(id)value forKey:(NSString *)key方法,实现原理
 功能:使用一个字符串标示符给一个对象的属性赋值.它支持普通对象和集合对象
  这个方法的默认实现如下:
 (1).首先去接收者(调用方法的那个对象)的类中查找与key相匹配的访问器方法(-set),如果找到了一个方法,就检查它参数的类型,如果它的参数类型不是一个对象指针类型,但是值为nil,就会执行setNilValueForKey:方法,setNilValueForKey:方法的默认实现,是产生一个NSInvalidArgumentException的异常,但是你可以重写这个方法.如果方法参数的类是一个对象指针类型,就会简单的执行这个方法,传入对应的参数.如果方法的参数类型是NSNumber或NSValue的对应的基本类型,先把它转换为基本数据类,再执行方法,传入转换后的数据.
 (2).如果没有对应的访问器方法(setter方法),如果接受者的类的+accessInstanceVariablesDirectly方法返回YES,那么就查找这个接受者的与key相匹配的实例变量(匹配模式为_,_is,,is):比如:key为age,只要属性存在_age,_isAge,age,isAge中的其中一个就认为匹配上了,如果找到这样的一个实例变量,并且的类型是一个对象指针类型,首先released对象上的旧值,然后把传入的新值retain后的传入的值赋值该成员变量,如果方法的参数类型是NSNumber或NSValue的对应的基本类型,先把它转换为基本数据类,再执行方法,传入转换后的数据.
 (3).如果访问器方法和实例变量都没有找到,执行setValue:forUndefinedKey:方法,该方法的默认实现是产生一个 NSUndefinedKeyException 类型的异常,但是我们可以重写setValue:forUndefinedKey:方法</description>
    </item>
    
    <item>
      <title>检测版本更新app</title>
      <link>http://wangerk.com/blog-cn/2017/12/10/update-app/</link>
      <pubDate>Sun, 10 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/10/update-app/</guid>
      <description>一、实现思路 /** 实现思路 1.获取当前项目APP版本号 2.拿到AppStore项目版本号 3.对比版本号,实现更新功能 */  //一定要先配置自己项目在商店的APPID,配置完最好在真机上运行才能看到完全效果哦
#define STOREAPPID @&amp;ldquo;1234567890&amp;rdquo;
二、代码实现 //检测app更新 -(void)updateApp { //1.先获取当前工程项目版本号 NSDictionary *infoDic = [[NSBundlemainBundle]infoDictionary]; NSString *currentVersion = infoDic[@&amp;quot;CFBundleShortVersionString&amp;quot;]; //2.从网络获取appStore版本号 NSError *error; NSData *response = [NSURLConnectionsendSynchronousRequest:[NSURLRequestrequestWithURL:[NSURLURLWithString:[NSStringstringWithFormat:@&amp;quot;http://itunes.apple.com/cn/lookup?id=%@&amp;quot;,STOREAPPID]]]returningResponse:nilerror:nil]; //2.1没有内容 if (response == nil) { NSLog(@&amp;quot;你没有连接网络哦&amp;quot;); return; } //3.序列化解析 NSDictionary *appInfoDic = [NSJSONSerializationJSONObjectWithData:responseoptions:NSJSONReadingMutableLeaveserror:&amp;amp;error]; //3.1数据错误 if (error) { NSLog(@&amp;quot;hsUpdateAppError:%@&amp;quot;,error); return; } //3.2字典解析 NSArray *array = appInfoDic[@&amp;quot;results&amp;quot;]; NSDictionary *dic = array[0]; NSString *appStoreVersion = dic[@&amp;quot;version&amp;quot;]; //打印版本号 NSLog(@&amp;quot;当前版本号:%@\n商店版本号:%@&amp;quot;,currentVersion,appStoreVersion); //4.当前版本号小于商店版本号,就更新 if([currentVersion floatValue] &amp;lt; [appStoreVersion floatValue]) { UIAlertView *alert = [[UIAlertViewalloc]initWithTitle:@&amp;quot;版本有更新&amp;quot; message:[NSStringstringWithFormat:@&amp;quot;检测到新版本(%@),是否更新?</description>
    </item>
    
    <item>
      <title>观察者模式优缺点、使用场景</title>
      <link>http://wangerk.com/blog-cn/2017/12/08/observer-model/</link>
      <pubDate>Fri, 08 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/08/observer-model/</guid>
      <description>一、观察者模式优点：
1.观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。
由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。 如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。
 2.观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知，
二、观察者模式缺点：
1.如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
2.如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。
3.如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。
4.虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。
三、观察者模式的应用场景：
1、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。
2、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。</description>
    </item>
    
    <item>
      <title>多线程技术之GCD</title>
      <link>http://wangerk.com/blog-cn/2017/12/03/pay-blog/</link>
      <pubDate>Sun, 03 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/03/pay-blog/</guid>
      <description>GCD（Grand Central Dispatch）是 Apple 公司为了提高 OS X 和 iOS 系统在多核处理器上运行并行代码的能力而开发的一系列相关技术，它提供了对线程的高级抽象。GCD 是一整套技术，包含了语言级别的新功能，运行时库，系统级别的优化，这些一起为并发代码的执行提供了系统级别的广泛优化。所以，GCD 也是 Apple 推荐的多线程编程工具。
GCD 是系统层面的技术，除了可以被系统级应用使用，也可以被更普通的高级应用使用。使用 GCD 之后，应用就可以轻松地在多核系统上高效运行并发代码，而不用考虑繁琐的底层问题。GCD 在系统层面工作，能很好地满足所有应用的并行运行需求，将可用系统资源平衡地分配给它们。
GCD 提供了一套纯 C API。但是，它提供的 API 简单易用并且有功能强大的任务管理和多线程编程能力。GCD 需要和 blocks（Objective－C 的闭包）配合使用。block 是 GCD 执行单元。GCD 的任务需要被拆解到 block 中。block 被排入 GCD 的分发队列，GCD 会为你排期运行。GCD 创建，重用，销毁线程，基于系统资源以它认为合适的方式运行每个队列。所以，用户需要关心的细节并不多。
GCD 的使用也很简单，假设抢面包是个耗时操作，前面例子中的 Geroge 和 Totty 的工作都可以实现如下：
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
 // 并发队列中做耗时操作
 while (TRUE) {
 if(_cake &amp;gt; 0) {
 // 耗时操作
 [NSThread sleepForTimeInterval:0.5];
 _cake&amp;ndash;;
 _occupied = kSum - _cake;</description>
    </item>
    
    <item>
      <title>多线程技术之NSOperation</title>
      <link>http://wangerk.com/blog-cn/2017/12/01/nsoperation/</link>
      <pubDate>Fri, 01 Dec 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/12/01/nsoperation/</guid>
      <description>1.NSOperation做的事情比 NSThread 更多一些。通过继承 NSOperation，可以使子类获得一些线程相关的特性，进而可以安全地管理线程生命周期。比如，以线程安全的方式建立状态，取消线程。配合 NSOperationQueue，可以控制线程间的优先级和依赖性。这就给出了一套线程管理的基本方法。
 NSOperation 代表了一个独立的计算单元。一般，我们会把计算任务封装进 NSOperation 这个对象。NSOperation 是抽象类，但同时也提供了两个可以直接使用的实体子类：NSInvocationOperation 和 NSBlockOperation。NSInvocationOperation 用于将计算任务封装进方法，NSBlockOperation 用于将计算任务封装进 block。
 2. NSOperationQueue 则用于执行计算任务，管理计算任务的优先级，处理计算任务之间的依赖性。NSOperation 被添加到 NSOperationQueue 中之后，队列会按优先级和进入顺序调度任务，NSOperation 对象会被自动执行。
 仍然使用上一节 NSThread 中的模拟两人抢面包的例子。由于计算任务没有变化，所以 run 方法并不改变。但这里需要使用 NSOperation 和 NSOperationQueue 来代表两个抢面包的人，并给予他们不同的优先级。由于 NSOperation 也不处理线程间同步问题，所以你仍然需要一把在run 方法中会用到的线程锁：
 _lock = [[NSLock alloc] init];
  NSInvocationOperation *geroge = [[NSInvocationOperation alloc]initWithTarget:self
 selector:@selector(run:) object:@&amp;ldquo;Geroge&amp;rdquo;];
 geroge.queuePriority = NSOperationQueuePriorityHigh;
  NSInvocationOperation *operationTwo = [[NSInvocationOperation alloc]initWithTarget:self
 selector:@selector(run:) object:@&amp;ldquo;Totty&amp;rdquo;];
 totty.queuePriority = NSOperationQueuePriorityLow;</description>
    </item>
    
    <item>
      <title>plist权限</title>
      <link>http://wangerk.com/blog-cn/2017/11/27/plist-privacy/</link>
      <pubDate>Mon, 27 Nov 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/11/27/plist-privacy/</guid>
      <description>&amp;lt;!-- 相册 --&amp;gt; &amp;lt;key&amp;gt;NSPhotoLibraryUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能访问相册&amp;lt;/string&amp;gt; &amp;lt;!-- 相机 --&amp;gt; &amp;lt;key&amp;gt;NSCameraUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能访问相机&amp;lt;/string&amp;gt; &amp;lt;!-- 麦克风 --&amp;gt; &amp;lt;key&amp;gt;NSMicrophoneUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能访问麦克风&amp;lt;/string&amp;gt; &amp;lt;!-- 位置 --&amp;gt; &amp;lt;key&amp;gt;NSLocationUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能访问位置&amp;lt;/string&amp;gt; &amp;lt;!-- 在使用期间访问位置 --&amp;gt; &amp;lt;key&amp;gt;NSLocationWhenInUseUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能在使用期间访问位置&amp;lt;/string&amp;gt; &amp;lt;!-- 始终访问位置 --&amp;gt; &amp;lt;key&amp;gt;NSLocationAlwaysUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能始终访问位置&amp;lt;/string&amp;gt; &amp;lt;!-- 日历 --&amp;gt; &amp;lt;key&amp;gt;NSCalendarsUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能访问日历&amp;lt;/string&amp;gt; &amp;lt;!-- 提醒事项 --&amp;gt; &amp;lt;key&amp;gt;NSRemindersUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能访问提醒事项&amp;lt;/string&amp;gt; &amp;lt;!-- 运动与健身 --&amp;gt; &amp;lt;key&amp;gt;NSMotionUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能访问运动与健身&amp;lt;/string&amp;gt; &amp;lt;!-- 健康更新 --&amp;gt; &amp;lt;key&amp;gt;NSHealthUpdateUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能访问健康更新 &amp;lt;/string&amp;gt; &amp;lt;!-- 健康分享 --&amp;gt; &amp;lt;key&amp;gt;NSHealthShareUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能访问健康分享&amp;lt;/string&amp;gt; &amp;lt;!-- 蓝牙 --&amp;gt; &amp;lt;key&amp;gt;NSBluetoothPeripheralUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能访问蓝牙&amp;lt;/string&amp;gt; &amp;lt;!-- 媒体资料库 --&amp;gt; &amp;lt;key&amp;gt;NSAppleMusicUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;App需要您的同意,才能访问媒体资料库&amp;lt;/string&amp;gt;  </description>
    </item>
    
    <item>
      <title>多线程技术之NSThread</title>
      <link>http://wangerk.com/blog-cn/2017/11/25/nsthread/</link>
      <pubDate>Sat, 25 Nov 2017 21:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/11/25/nsthread/</guid>
      <description>一、NSThread
 NSThread 是 OS X 和 iOS 都提供的一个线程对象，它是线程的一个轻量级实现。在执行一些轻量级的简单任务时，NSThread 很有用，但用户仍然需要自己管理线程生命周期，进行线程间同步。比如，线程状态，依赖性，线程间同步等线程相关的主题 NSThread 都没有涉及。比如，涉及到线程间同步仍然需要配合使用 NSLock，NSCondition 或者 @synchronized。所以，遇到复杂任务时，轻量级的 NSThread 可能并不合适。
  提供一个模拟多线程运作的简单例子：两个人同时一起到烤箱抢面包。我们启动两个线程，来代表两个人。由于烤箱门比较小，同时只能有一个人去拿面包。由于 NSThread 不处理线程同步，所以为了模拟这个过程， 你还需要一把线程锁（即类型为 NSLock 的实例变量 _lock）。在后面的 run 方法中会用到这把线程锁：
  _lock = [[NSLock alloc] init];
  NSThread *geroge = [[NSThread alloc] itWithTarget:self selector:
 @selector(run) object:nil];
 [geroge setName:@&amp;ldquo;Geroge&amp;rdquo;];
 [geroge start];
  NSThread *totty = [[NSThread alloc] nitWithTarget:self selector:
 @selector(run) object:nil];
 [totty setName:@&amp;ldquo;Totty&amp;rdquo;];
 [totty start];</description>
    </item>
    
    <item>
      <title>多线程技术之performSelectors</title>
      <link>http://wangerk.com/blog-cn/2017/11/25/muti-thread-perform-selectors/</link>
      <pubDate>Sat, 25 Nov 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/11/25/muti-thread-perform-selectors/</guid>
      <description>NSObject 提供了以 performSelector 为前缀的一系列方法。它们可以让用户在指定线程中，或者立即，或者延迟执行某个方法调用。这个方法给了用户实现多线程编程最简单的方法。
下面有一些例子：
 1.在当前线程中执行方法：
 - (void)performSelector:(SEL)aSelector withObject:(id)anArgument
 afterDelay:(NSTimeInterval)delay
 - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:
 (NSTimeInterval)delay inModes:(NSArray *)modes
 2.在指定线程中执行方法：
 - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread
 withObject:(id)arg waitUntilDone:(BOOL)wait
  - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:
 (id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array
 3.在主线程中执行方法：
 - (void)performSelectorOnMainThread: (SEL)selector withObject:(id)argument
 waitUntilDone:(BOOL)wait
 - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg
 waitUntilDone:(BOOL)wait modes:(NSArray *)array
 4.在后台线程中执行方法：
 - (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg
 这一系列方法简单易用，但只提供了有限的几个选择：指定执行的方法（但传入方法的参数数量有限制）；指定是在当前线程，还是在主线程，还是在后台线程执行；指定是否需要阻塞当前线程等待结果。
 例如，以下代码使得方法 foo: 在一个新的后台线程执行，并传入了 object 参数：</description>
    </item>
    
    <item>
      <title>ReactiveCocoa方法介绍</title>
      <link>http://wangerk.com/blog-cn/2017/11/19/rac/</link>
      <pubDate>Sun, 19 Nov 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/11/19/rac/</guid>
      <description>一、RAC内存管理
RAC会维护一个全局的信号集合，一个或多于一个订阅者就可用，所有订阅者都被移除了，信号就被释放了。
RAC的API手册
常见类
RACSiganl 信号类。
  RACEmptySignal ：空信号，用来实现 RACSignal 的 +empty 方法；
  RACReturnSignal ：一元信号，用来实现 RACSignal 的 +return: 方法；
  RACDynamicSignal ：动态信号，使用一个 block - 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例；
  RACErrorSignal ：错误信号，用来实现 RACSignal 的 +error: 方法；
  RACChannelTerminal ：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。
  RACSubscriber 订阅者
RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。
  RACSerialDisposable ：作为 disposable 的容器使用，可以包含一个 disposable 对象，并且允许将这个 disposable 对象通过原子操作交换出来；
  RACKVOTrampoline ：代表一次 KVO 观察，并且可以用来停止观察；
  RACCompoundDisposable ：它可以包含多个 disposable 对象，并且支持手动添加和移除 disposable 对象</description>
    </item>
    
    <item>
      <title>友盟统计界面次数</title>
      <link>http://wangerk.com/blog-cn/2017/11/10/umeng-touch-statistic/</link>
      <pubDate>Fri, 10 Nov 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/11/10/umeng-touch-statistic/</guid>
      <description> 一、初始化 #import &amp;quot;AppDelegate.h&amp;quot; #import &amp;quot;MobClick.h&amp;quot; #import &amp;quot;ViewController.h&amp;quot; @interface AppDelegate () @end @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { //1.初始化友盟统计模块 [MobClick startWithAppkey:@&amp;quot;是申请的 Key 名例如是 abcvxsdhufh&amp;quot; reportPolicy:BATCH channelId:nil]; //配置 NSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@&amp;quot;CFBundleShortVersionString&amp;quot;]; [MobClick setAppVersion:version]; //设置ViewController添加到导航栏上 ViewController *vc = [[ViewController alloc]init]; UINavigationController * nvc = [[UINavigationController alloc]initWithRootViewController:vc]; //ViewController为主控制器 self.window.rootViewController = nvc; self.window.backgroundColor = [UIColor whiteColor]; return YES; }  二、页面代码 //视图将要显示的时候 - (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; //开始视图里面的日志页面: [MobClick beginLogPageView:@&amp;quot;PageOne&amp;quot;]; } //视图将要消失的时候 - (void)viewWillDisappear:(BOOL)animated { [super viewWillDisappear:animated]; [MobClick endLogPageView:@&amp;quot;PageOne&amp;quot;]; }  </description>
    </item>
    
    <item>
      <title>NSDictionary实现原理</title>
      <link>http://wangerk.com/blog-cn/2017/11/06/nsdictionary/</link>
      <pubDate>Mon, 06 Nov 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/11/06/nsdictionary/</guid>
      <description> NSDictionary使用原理  1.NSDictionary（字典）是使用 hash表来实现key和value之间的映射和存储的， hash函数设计的好坏影响着数据的查找访问效率。
 - (void)setObject:(id)anObject forKey:(id )aKey;
 2.Objective-C 中的字典 NSDictionary 底层其实是一个哈希表，实际上绝大多数语言中字典都通过哈希表实现
 二、哈希的原理  哈希概念:哈希表的本质是一个数组，数组中每一个元素称为一个箱子(bin)，箱子中存放的是键值对。
 三、哈希表的存储过程:  1.根据 key 计算出它的哈希值 h。
2.假设箱子的个数为 n，那么这个键值对应该放在第 (h % n) 个箱子中。
3.如果该箱子中已经有了键值对，就使用开放寻址法或者拉链法解决冲突。
 .
 在使用拉链法解决哈希冲突时，每个箱子其实是一个链表，属于同一个箱子的所有键值对都会排列在链表中。
哈希表还有一个重要的属性: 负载因子(load factor)，它用来衡量哈希表的 空/满 程度，一定程度上也可以体现查询的效率，计算公式为:
负载因子 = 总键值对数 / 箱子个数
负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，哈希表将自动扩容。
 .
 重哈希概念: 哈希表在自动扩容时，一般会创建两倍于原来个数的箱子，因此即使 key 的哈希值不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。
哈希表的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。
 四、总结  细心的读者可能会发现哈希表的两个问题:
1.如果哈希表中本来箱子就比较多，扩容时需要重新哈希并移动数据，性能影响较大。
2.如果哈希函数设计不合理，哈希表在极端情况下会变成线性表，性能极低。
 </description>
    </item>
    
    <item>
      <title>Runloop相关</title>
      <link>http://wangerk.com/blog-cn/2017/11/01/runloop/</link>
      <pubDate>Wed, 01 Nov 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/11/01/runloop/</guid>
      <description>一、RunLoop和线程的关系:
1.RunLoop 的作用就是来管理线程的，当线程的 RunLoop开启后，线程就会在执行完任务后，处于休眠状态，随时等待接受新的任务，而不是退出。
2.只有主线程的RunLoop是默认开启的，所以程序在开启后，会一直运行，不会退出。其他线程的RunLoop如果需要开启，就手动开启，
二、runloop内部是如何实现的:
1、有一个判断循环的条件，满足条件，就一直循环
2、线程得到唤醒事件被唤醒，事件处理完毕以后，回到睡眠状态，等待下次唤醒
二、runloop的mode作用是什么?:
1.model 主要是用来指定事件在运行循环中的优先级的，分为：
 NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态
 UITrackingRunLoopMode ：ScrollView滑动时
 UIInitializationRunLoopMode ：启动时
 NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合
  2.苹果公开提供的 Mode有两个：
 NSDefaultRunLoopMode（kCFRunLoopDefaultMode）
 NSRunLoopCommonModes（kCFRunLoopCommonModes）
  </description>
    </item>
    
    <item>
      <title>类方法load和initialize的区别</title>
      <link>http://wangerk.com/blog-cn/2017/10/31/load-initialize/</link>
      <pubDate>Tue, 31 Oct 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/10/31/load-initialize/</guid>
      <description>一、+load:
1/方法当类或分类添加到object-c runtime时被调用
2/子类的+load方法会在它所有父类的+load方法之后执行，
3/而分类的+load方法会在它的主类的+load方法之后执行,
4.+load方法，它不遵循那套继承规则。
5.+load方法调用顺序是：SuperClass &amp;ndash;&amp;gt;SubClass &amp;ndash;&amp;gt; CategaryClass。
6.load，是加载类的时候，这里是Constants类，就会调用。也就是说，ios应用启动的时候，就会加载所有的类，就会调用这个方法。
注意:这样有个缺点，当加载类需要很昂贵的资源，或者比较耗时的时候，可能造成不良的用户体验，或者系统的抖动（dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{});用GCD可能会好点）。
二、+initialize
1/是在类或者它的子类接受第一条消息前被调用;
2/是以懒加载的方式被调用的;
3/一定会在“线程安全的环境”中执行;
4/调用顺序是SuperClass &amp;ndash;&amp;gt;SubClass 。
5/initialize 会在运行时仅被触发一次，如果没有向类发送消息的话，这个方法将不会被调用。这个方法的调用是线程安全的。父类会比子类先收到此消息。</description>
    </item>
    
    <item>
      <title>Charles抓包</title>
      <link>http://wangerk.com/blog-cn/2017/10/09/charles/</link>
      <pubDate>Mon, 09 Oct 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/10/09/charles/</guid>
      <description>（1）查看电脑IP地址 （2）设置手机HTTP代理
手机连上电脑，点击“设置-&amp;gt;无线局域网-&amp;gt;连接的WiFi”，设置HTTP代理：
服务器为电脑IP地址：如192.168.1.169
端口：8888 设置代理后，需要在电脑上打开Charles才能上网
（3）电脑上打开Charles进行HTTP抓包
手机上打开某个App或者浏览器什么的，如果不能上网，检查前面步骤是否正确 点击“Allow”允许，出现手机的HTTP请求列表 </description>
    </item>
    
    <item>
      <title>delegate和NSNotification比较</title>
      <link>http://wangerk.com/blog-cn/2017/10/03/delegate-nsnotification/</link>
      <pubDate>Tue, 03 Oct 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/10/03/delegate-nsnotification/</guid>
      <description>delegate方法比notification更加直接，最典型的特征是，delegate方法往往需要关注返回值，也就是delegate方法的结果。
比如-windowShouldClose: 需要关心返回的是yes还是no。所以delegate方法往往包含 should这个很传神的词。也就是好比你做我的delegate，我会问你我想关闭窗口你愿意吗？你需要给我一个答案，我根据你的答案来决定如何做下一步。相反的，notification最大的特色就是不关心接受者的态度，我只管把通告放出来，你接受不接受就是你的事情，同时我也不关心结果。
所以notification往往用did这个词汇，比如NSWindowDidResizeNotification，那么NSWindow对象放出这个notification后就什么都不管了也不会等待接受者的反应。</description>
    </item>
    
    <item>
      <title>log宏</title>
      <link>http://wangerk.com/blog-cn/2017/09/15/log/</link>
      <pubDate>Fri, 15 Sep 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/09/15/log/</guid>
      <description>// 直接替换
#ifdef DEBUG
#define NSLog(&amp;hellip;) NSLog(VA_ARGS)
#define debugMethod() NSLog(@&amp;ldquo;%s&amp;rdquo;, func)
#else
#define NSLog(&amp;hellip;)
#define debugMethod()
#endif</description>
    </item>
    
    <item>
      <title>block为什么要用copy</title>
      <link>http://wangerk.com/blog-cn/2017/09/10/block-cpy/</link>
      <pubDate>Sun, 10 Sep 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/09/10/block-cpy/</guid>
      <description>一、栈区和堆区概念
内存的栈区 : 由编译器自动分配释放, 存放函数的参数值, 局部变量的值等. 其操作方式类似于数据结构中的栈.
内存的堆区 : 一般由程序员分配释放, 若程序员不释放, 程序结束时可能由OS回收. 注意它与数据结构中的堆是两回事, 分配方式倒是类似于链表.
二、block用copy作用域
首先, block是一个对象, 所以block理论上是可以retain/release的. 但是block在创建的时候它的内存是默认是分配在栈(stack)上, 而不是堆(heap)上的. 所以它的作用域仅限创建时候的当前上下文(函数, 方法&amp;hellip;), 当你在该作用域外调用该block时, 程序就会崩溃.
官方文档: 注意:
1.一般情况下你不需要自行调用copy或者retain一个block. 只有当你需要在block定义域以外的地方使用时才需要copy. Copy将block从内存栈区移到堆区.
2.其实block使用copy是MRC留下来的也算是一个传统吧, 在MRC下, 如上述, 在方法中的block创建在栈区, 使用copy就能把他放到堆区, 这样在作用域外调用该block程序就不会崩溃. 3.但在ARC下, 使用copy与strong其实都一样, 因为block的retain就是用copy来实现的, 所以block使用copy还能装装逼, 说明自己是从MRC下走过来的</description>
    </item>
    
    <item>
      <title>深拷贝</title>
      <link>http://wangerk.com/blog-cn/2017/09/09/deep-copy/</link>
      <pubDate>Sat, 09 Sep 2017 21:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/09/09/deep-copy/</guid>
      <description>一、深拷贝概念
1.深拷贝:是直接拷贝整个对象的内存到另一块内存中。
2.在Objective-C中，通过两个方法 copy和mutableCopy可以执行拷贝操作，其中copy是获得一个不可变对象，而mutableCopy是获得一个可变对象。
3.并且两个方法分别调用copyWithZone和mutableCopyWithZone两个方法来进行拷贝操作，一个类必须实现copyWithZone或者mutableCopyWithZone，才能进行copy或者mutableCopy
二、集合的深拷贝代码实现
有两种方法:
第一个方法是
可以用initWithArray:copyItems:将第二个参数设置为YES即可深拷贝，如：
NSDictionary shallowCopyDict = [[NSDictionary alloc]initWithDictionary:someDictionary copyItems:YES];
如果你用这种方法深拷贝，集合里的每个对象都会收到copyWithZone:消息。如果集合里的对象都遵循NSCopying协议，那么对象就会被深拷贝到新的集合。如果对象没有遵循 NSCopying协议，而尝试用这种方法进行深拷贝，会在运行时出错。copyWithZone:这种拷贝方式只能够提供单层内存拷贝(one-level-deep copy)，而非真正的深拷贝。
第二个方法是将集合进行归档(archive)，然后解档(unarchive)，
如：
NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];
注意：
 第一种方式copyWithZone:这种拷贝方式只能够提供单层内存拷贝(one-level-deep copy)，而非真正的深拷贝。
 第二种方式归档和解档才是实现真正的深拷贝。
  one-level-deep copy 集合的单层深拷贝
这里需要区分一个概念性的问题：
如果在多层数组中，对第一层进行内容拷贝，其它层进行指针拷贝，这种情况是属于深拷贝，还是浅拷贝？对此，苹果官网文档有这样一句话描述：
/**
This kind of copy is only capable of producing a one-level-deep copy.
If you only need a one-level-deep copy, you can explicitly call for one as in Listing
*/
1.苹果认为这种拷贝不是真正的深拷贝，而是将其称为单层深拷贝(one-level-deep copy)。 2.</description>
    </item>
    
    <item>
      <title>浅拷贝</title>
      <link>http://wangerk.com/blog-cn/2017/09/09/shallow-copy/</link>
      <pubDate>Sat, 09 Sep 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/09/09/shallow-copy/</guid>
      <description>一、浅拷贝概念
1.浅拷贝:只是拷贝了对象的指针，而不是拷贝对象本身。
2.在Objective-C中，通过两个方法 copy和mutableCopy可以执行拷贝操作，其中copy是获得一个不可变对象，而mutableCopy是获得一个可变对象。
3.并且两个方法分别调用copyWithZone和mutableCopyWithZone两个方法来进行拷贝操作，一个类必须实现copyWithZone或者mutableCopyWithZone，才能进行copy或者mutableCopy 二、浅拷贝代码实现
浅拷贝有很多中方法，当你进行浅拷贝时,会向原始的集合发送retain消息，这时引用计数就会 +1 ，同时指针就被拷贝到新的集合中去。
NSArray *shallowCopyArray = [someArray copyWithZone:nil];
NSDictionary *shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:NO];
注意:如果集合里的对象都遵循NSCopying 协议，那么对象就会被深拷贝到新的集合。如果对象没有遵循 NSCopying 协议，而尝试用这种方法进行深拷贝，会在运行时出错。
三、浅拷贝、深拷贝、完全拷贝区别:
 浅拷贝(shallow copy)： 在浅拷贝操作时，对于被拷贝对象的每一层都是指针拷贝。
 深拷贝(one-level-deep copy)：在深拷贝操作时，对于被拷贝对象，至少有一层是深拷贝。
 完全拷贝(real-deep copy)： 在完全拷贝操作时，对于被拷贝对象的每一层都是对象拷贝
  四、系统对象的拷贝
不管是集合类对象，还是非集合类对象，当接收到copy和mutableCopy消息时，都遵循以下准则：
copy返回不可变对象(immutable)；所以，如果对copy返回值使用mutable对象接口就会crash； mutableCopy返回可变对象(mutable);</description>
    </item>
    
    <item>
      <title>多媒体</title>
      <link>http://wangerk.com/blog-cn/2017/08/29/media/</link>
      <pubDate>Tue, 29 Aug 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/08/29/media/</guid>
      <description>一、AVPlayer介绍
1.能播放本地、远程的音频、视频文件
2.基于Layer显示，得自己去编写控制面板
3.AVPlayer(远程⾳音乐/播放视频)—&amp;gt;添加layer
4.可以播放远程视频(需要通过添加layer来显示视频)
代码实现
#pragma mark - 懒加载代码 - (AVPlayer *)player { if (_player == nil) { // 1.获取URL(远程/本地) // NSURL *url = [[NSBundle mainBundle] URLForResource:@&amp;quot;01-知识回顾.mp4&amp;quot; withExtension:nil]; NSURL *url = [NSURL URLWithString:@&amp;quot;http://v1.mukewang.com/a45016f4-08d6-4277-abe6-bcfd5244c201/L.mp4&amp;quot;]; // 2.创建AVPlayerItem AVPlayerItem *item = [AVPlayerItem playerItemWithURL:url]; // 3.创建AVPlayer _player = [AVPlayer playerWithPlayerItem:item]; // 4.添加AVPlayerLayer AVPlayerLayer *layer = [AVPlayerLayer playerLayerWithPlayer:self.player]; layer.frame = CGRectMake(0, 0, self.view.bounds.size.width, self.view.bounds.size.width * 9 / 16); [self.view.layer addSublayer:layer]; } return _player; }  二、MPMoviePlayerController介绍</description>
    </item>
    
    <item>
      <title>VR AR MR简介</title>
      <link>http://wangerk.com/blog-cn/2017/08/28/vr-ar-mr/</link>
      <pubDate>Mon, 28 Aug 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/08/28/vr-ar-mr/</guid>
      <description>一、VR(虚拟现实)概念
VR：
 1.是虚拟现实Virtual Reality的英语缩写(简称VR,又译作灵境、幻真,是近年来出现的高新技术，也称灵境技术或人工环境)。
 2.虚拟现实技术是一种可以创建和体验虚拟世界的计算机仿真系统它利用计算机生成一种模拟环境是一种多源信息融合的交互式的三维动态视景和实体行为的系统仿真使用户沉浸到该环境中。
 3.虚拟现实是利用电脑模拟产生一个三维空间的虚拟世界，提供使用者关于视觉、听觉、触觉等感官的模拟，让使用者如同身历其境一般，可以及时、没有限制地观察三度空间内的事物。
二、AR(增强现实)概念
AR：
 1.是增强现实Augmented Reality的英文缩写(简称AR，也被称之为混合现实)。
 2.增强现实通过电脑技术，将虚拟的信息应用到真实世界，真实的环境和虚拟的物体实时地叠加到了同一个画面或空间同时存在
 3.增强现实是一种实时地计算摄影机影像的位置及角度并加上相应图像的技术，这种技术的目标是在屏幕上把虚拟世界套在现实世界并进行互动。这种技术最早于1990年提出。随着随身电子产品运算能力的提升，增强现实的用途越来越广。
三、MR(混合现实)概念
MR：
 1.是混合现实Mixed Reality的英文缩写(简称MR)。
 2.混合现实包括增强现实和增强虚拟，指的是合并现实和虚拟世界而产生的新的可视化环境。在新的可视化环境里物理和数字对象共存，并实时互动。系统通常采用三个主要特点：A. 它结合了虚拟和现实；B. 在虚拟的三维（3D注册）； C. 实时运行。
 3.混合现实技术是虚拟现实技术的进一步发展，该技术通过在虚拟环境中引入现实场景信息，在虚拟世界、现实世界和用户之间搭起一个交互反馈的信息回路，以增强用户体验的真实感。
四、VR和AR的区别：
　简单来说，虚拟现实（VR），看到的场景和人物全是假的，是把你的意识代入一个虚拟的世界。增强现实（AR），看到的场景和人物一部分是真一部分是假，是把虚拟的信息带入到现实世界中。
五、VR和AR交互区别：　　VR设备：因为VR是纯虚拟场景，所以VR装备更多的是用于用户与虚拟场景的互动交互，更多的使用是：位置跟踪器、数据手套（5DT之类的）、动捕系统、数据头盔等等。
　AR设备：由于AR是现实场景和虚拟场景的结合，所以基本都需要摄像头，在摄像头拍摄的画面基础上，结合虚拟画面进行展示和互动，比如GOOGLE GLASS这些（其实严格的来说，IPAD，手机这些带摄像头的只能产品，都可以用于AR，只要安装AR的软件就可以。）
六、 VR 和 AR技术区别
　类似于游戏制作，创作出一个虚拟场景供人体验，其核心是graphics的各项技术的发挥。和我们接触最多的就是应用在游戏上，可以说是传统游戏娱乐设备的一个升级版，主要关注虚拟场景是否有良好的体验。而与真实场景是否相关，他们并不关心。VR设备往往是浸入式的，典型的设备就是oculus rift。
　AR应用了很多computer vision的技术。AR设备强调复原人类的视觉的功能，比如自动去识别跟踪物体，而不是我手动去指出；自主跟踪并且对周围真实场景进行3D建模，而不是我打开Maya照着场景做一个极为相似的。典型的AR设备就是普通移动端手机，升级版如Google Project Tango</description>
    </item>
    
    <item>
      <title>block原理</title>
      <link>http://wangerk.com/blog-cn/2017/08/27/block/</link>
      <pubDate>Sun, 27 Aug 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/08/27/block/</guid>
      <description>一、blcok概念
block：可以理解为匿名的函数，就是预先准备好的一段代码，在需要的时候调用。
二、底层实现
1.block是一个指针结构体，在终端下通过clang -rewrite-objc 指令看看C++代码。
 利用终端编译生成C++代码： clang -rewrite-objc main.m
2.几个重要的结构体和函数简介：
__block_impl：这是一个结构体，也是C面向对象的体现，可以理解为block的基类;
__main_block_impl_0: 可以理解为block变量;
__main_block_func_0: 可以理解为匿名函数；
__main_block_desc_0:block的描述, Block_size;
3.注意事项：block容易造成循环引用，在block里面如果使用了self，然后形成强引用时，需要打断循环引用；在MRC下用_block，在ARC下使用__weak;
三、 block 实现原理 Objective-C是对C语言的扩展，block的实现是基于指针和函数指针。 从计算语言的发展，最早的goto，高级语言的指针，到面向对象语言的block，从机器的思维，一步步接近人的思维，以方便开发人员更为高效、直接的描述出现实的逻辑
四、block 储存位置
block快的存储位置（block入口的地址）可能存放在3个地方：代码区（全局区）、堆区、栈区（ARC情况下回自动拷贝到堆区、因此ARC下只有两个地方：代码区和堆区）。
代码区：不访问栈区的变量（如局部变量），且不访问堆区的变量（如用alloc创建的对象）时，此时block存放在代码区； 堆区：如果访问了堆区的变量（如局部变量），或堆区的变量（如用alloc创建的对象），此时block存方在堆区； &amp;ndash;需要注意 实际是放在栈区，在ARC情况下自动拷贝到堆区，如果不是ARC则存放在栈区，所在函数执行完毕就回释放，想再外面调用需要用copy指向它，这样就拷贝到了堆区，strong属性不会拷贝、会造成野指针错区。（需要理解ARC是一种编译器特性，即编译器在编译时在核实的地方插入retain、release、autorelease，而不是iOS的运行时特性）。
此外代码存在堆区时,需要注意，因为堆区不像代码区不变化，堆区是动态的（不断的创建销毁），当没有强指针指向的时候就会被销毁，如果再去访问这段代码时，程序就会崩溃！所以此种情况在定义block属性时需要指定为strong or copy。block是一段代码，即不可变，所以使用copy也不会深拷贝。
 Block如果没有引用外部变量
保存在全局区（MRC/ARC一样）
Block如果引用外部变量
ARC保存在 堆区； MRC保存在 栈区必须用copy修饰block；
 </description>
    </item>
    
    <item>
      <title>内存分析优化</title>
      <link>http://wangerk.com/blog-cn/2017/08/25/oc-memory/</link>
      <pubDate>Fri, 25 Aug 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/08/25/oc-memory/</guid>
      <description>一.内存分析
1.静态分析(Analyze)
不运行程序, 直接检测代码中是否有潜在的内存问题(不一定百分百准确,仅仅是提供建议)
结合实际情况来分析,是否真的有内存问题
2.动态分析(Profile == Instruments)
1&amp;gt; 运行程序,通过使用app,查看内存的分配情况(Allocations)
 可以查看做出了某个操作后(比如点击了某个按钮\显示了某个控制器),内存是否有暴增的情况(突然变化)  2&amp;gt; 运行程序,通过使用app,查看是否有内存泄漏(Leaks)
 红色区域代表内存泄漏出现的地方  二.内存使用注意
1.加载小图片\使用频率比较高的图片
1&amp;gt;利用imageNamed:方法加载过的图片,永远有缓存,这个缓存是由系统管理的,无法通过代码销毁缓存
2.加载大图片\使用频率比较低的图片(一次性的图片,比如版本新特性的图片)
1&amp;gt; 利用initWithContentsOfFile:\imageWithContentsOfFile:\imageWithData:等方法加载过的图片,没有缓存,只要用完了,就会自动销毁
2&amp;gt;基本上,除imageNamed:方法以外,其他加载图片的方式,都没有缓存
三.2个专业术语
1.内存泄漏
1&amp;gt;该释放的对象,没有被释放(已经不再使用的对象,没有被释放)
2.内存溢出(Out Of Memory)
1&amp;gt;内存不够用了
2&amp;gt;数据长度比较小的数据类型存储了数据长度比较大的数据
四.图片在沙盒中的存在形式
1.如果项目的Deployment Target &amp;lt;=6.x (不支持图片压缩)
1&amp;gt; 所有图片直接暴露在沙盒的资源包(main Bundle),不会压缩到Assets.car文件
2.如果项目的Deployment Target &amp;gt;=7.x (支持图片压缩)
1&amp;gt; 放在Images.xcassets里面的所有图片会压缩到Assets.car文件,不会直接暴露在沙盒的资源包(main Bundle)
2&amp;gt; 没有放在Images.xcassets里面的所有图片会直接暴露在沙盒的资源包(main Bundle), 不会压缩到Assets.car文件
3.总结
1&amp;gt; 会压缩到Assets.car文件,没有直接暴露在沙盒的资源包(main Bundle)
 条件 :&amp;ldquo;Deployment Target &amp;gt;= 7.x&amp;rdquo;并且是&amp;rdquo;放在Images.xcassets里面的所有图片&amp;rdquo;
 影响 :无法得到图片的全路径,只能通过图片名(imageNamed:方法)来加载图片,永远会有缓存
  2&amp;gt; 不会压缩到Assets.car文件,直接暴露在沙盒的资源包(main Bundle)</description>
    </item>
    
    <item>
      <title>路径图</title>
      <link>http://wangerk.com/blog-cn/2017/08/15/path-drawing/</link>
      <pubDate>Tue, 15 Aug 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/08/15/path-drawing/</guid>
      <description>一、GIF 效果图: 二、连线视图的效果图: 三、实现代码:
控制器1: SHContext.h // // SHContext.h // PathDrawing(路径图)~demo // // Created by . on 2017/8/15. // Copyright © 2017年 shihu. All rights reserved. // #ifndef SHContext_h #define SHContext_h /* 该方法负责绘制圆角矩形 x1、y2：是圆角矩形左上角的座标。 width、height：控制圆角举行的宽、高 radius：控制圆角矩形的四个圆角的半径 */ void CGContextAddRoundRect(CGContextRef c, CGFloat x1 , CGFloat y1 , CGFloat width , CGFloat height , CGFloat radius) { // 移动到左上角 CGContextMoveToPoint (c, x1 + radius , y1); // 添加一条连接到右上角的线段 CGContextAddLineToPoint(c , x1 + width - radius, y1); // 添加一段圆弧 CGContextAddArcToPoint(c , x1 + width , y1, x1 + width , y1 + radius, radius); // 添加一条连接到右下角的线段 CGContextAddLineToPoint(c , x1 + width, y1 + height - radius); // 添加一段圆弧 CGContextAddArcToPoint(c , x1 + width, y1 + height , x1 + width - radius , y1 + height , radius); // 添加一条连接到左下角的线段 CGContextAddLineToPoint(c , x1 + radius, y1 + height); // 添加一段圆弧 CGContextAddArcToPoint(c , x1, y1 + height , x1 , y1 + height - radius , radius); // 添加一条连接到左上角的线段 CGContextAddLineToPoint(c , x1 , y1 + radius); // 添加一段圆弧 CGContextAddArcToPoint(c , x1 , y1 , x1 + radius , y1 , radius); } /* 该方法负责绘制多角星。 n：该参数通常应设为奇数，控制绘制N角星。 dx、dy：控制N角星的中心。 size：控制N角星的大小 */ void CGContextAddStar(CGContextRef c , NSInteger n , CGFloat dx , CGFloat dy , NSInteger size) { CGFloat dig = 4 * M_PI / n ; // 移动到指定点 CGContextMoveToPoint(c , dx , dy + size); for(int i = 1 ; i &amp;lt;= n ; i++) { CGFloat x = sin(i * dig); CGFloat y = cos(i * dig); // 绘制从当前点连接到指定点的线条 CGContextAddLineToPoint(c , x * size + dx ,y * size + dy); } } #endif /* SHContext_h */ ========================= =================================================== 控制器2: SHPathDrawingView.</description>
    </item>
    
    <item>
      <title>NSSet和NSMutableSet</title>
      <link>http://wangerk.com/blog-cn/2017/06/12/nsset-nsmutableset/</link>
      <pubDate>Mon, 12 Jun 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/06/12/nsset-nsmutableset/</guid>
      <description>NSSet和NSMutableSet是无序的, 但是它保证数据的唯一性。当插入相同的数据时，不会有任何效果。从内部实现来说是hash表，所以可以常数时间内查找一个数据。
 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
 给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数
NSSet和NSMutableSet是无序的, 但是它保证数据的唯一性。当插入相同的数据时，不会有任何效果。从内部实现来说是hash表，所以可以常数时间内查找一个数据。
 IOS开发之&amp;mdash;-NSSet和NSMutableSet
 1、NSSet的使用
 [NSSet setWithSet:(NSSet *)set]; 用另外一个set对象构造
 [NSSet setWithArray:(NSArray *)array];用数组构造
 [NSSet setWithObjects:&amp;hellip;]:创建集合对象，并且初始化集合中的数值，结尾必需使用nil标志。
 [set count] ; 得到这个结合对象的长度。
 [set containsObject:&amp;hellip;]: 判断这个集合中是否存在传入的对象，返回Bool值。
 [set objectEnumerator]: 将集合放入迭代器。
 [enumerator nextObject]:得到迭代器中的下一个节点数据，使用while遍历这个迭代器，方可遍历集合对象中的对象。
 [set isEqualToSet:objset]:判断两个集合是否完全相等,返回Bool值。
 [set isSubsetOfSet:objset]:判断集合中的所有数据是否都相等与objeset集合中,返回Bool值。
 [set allObjects];
  示例代码：
 1.1 以NSArray构造set
  NSArray *array = [[NSArray alloc] initWithObjects:@&amp;ldquo;对象abc&amp;rdquo;,@&amp;ldquo;rongfzh&amp;rdquo;, @&amp;ldquo;totogo2010&amp;rdquo;,nil];
 NSSet *set3 = [NSSet setWithArray:array];</description>
    </item>
    
    <item>
      <title>ARC和MRC混合开发</title>
      <link>http://wangerk.com/blog-cn/2017/06/10/arc-mrc/</link>
      <pubDate>Sat, 10 Jun 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/06/10/arc-mrc/</guid>
      <description>ARC &amp;amp; MRC 混合开发
在项目开发中，遇到使用MRC开发的第三方库怎么办？
例如：ASI
1&amp;gt;尝试使用Xcode的转换工具（失败率比较高）
2&amp;gt; 在编译选项中，为MRC的程序添加-fno-objc-arc标记，表明在编译时，该文件使用MRC编译
备注：
(1) 演示中使用的RegexKitLite还需要导入libicucore.dylib动态库
(2) 如果要在MRC项目中添加ARC的文件，可以使用 -fobjc-arc 标记即可
3&amp;gt; 将MRC的第三方库直接编译成静态库使用
注意：在编译静态库时，不能添加动态库引用
说明：
RegexKitLite是对NSString添加的正则表达式分类
*** 在项目中，如果使用的静态库中包含分类，则需要在Other Link Flag中添加 -ObjC选项</description>
    </item>
    
    <item>
      <title>程序启动的完整过程</title>
      <link>http://wangerk.com/blog-cn/2017/06/09/program-flow/</link>
      <pubDate>Fri, 09 Jun 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/06/09/program-flow/</guid>
      <description>1步.main函数
2步.UIApplicationMain
 创建UIApplication对象
 创建UIApplication的delegate对象
  3步.delegate对象开始处理(监听)系统事件(没有storyboard)
 程序启动完毕的时候, 就会调用代理的application:didFinishLaunchingWithOptions:方法
 在application:didFinishLaunchingWithOptions:中创建UIWindow
 创建和设置UIWindow的rootViewController
 显示窗口
  3.1步.根据Info.plist获得最主要storyboard的文件名,加载最主要的storyboard(有storyboard)
 创建UIWindow
 创建和设置UIWindow的rootViewController
 显示窗口
  </description>
    </item>
    
    <item>
      <title>客户端HTTP状态码</title>
      <link>http://wangerk.com/blog-cn/2017/06/07/http-code/</link>
      <pubDate>Wed, 07 Jun 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/06/07/http-code/</guid>
      <description>1xx消息
这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。
100 Continue
 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。
101 Switching Protocols
 服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。: 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。
102 Processing
 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。
2xx成功
这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。
200 OK
 请求已成功，请求所希望的响应头或数据体将随此响应返回。
201 Created
 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回&amp;rsquo;202 Accepted&amp;rsquo;。
202 Accepted
 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。
203 Non-Authoritative Information
 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。
204 No Content
 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。
 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。
 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。
205 Reset Content
 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。
 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。
206 Partial Content
 服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。
 该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。
 响应必须包含如下的头部域：
 Content-Range用以指示本次响应中返回的内容的范围；如果是Content-Type为multipart/byteranges的多段下载，则每一multipart段中都应包含Content-Range域用以指示本段的内容范围。假如响应中包含Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。
 Date
 ETag和／或Content-Location，假如同样的请求本应该返回200响应。</description>
    </item>
    
    <item>
      <title>滚动到顶部</title>
      <link>http://wangerk.com/blog-cn/2017/06/04/tap-scroll/</link>
      <pubDate>Sun, 04 Jun 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/06/04/tap-scroll/</guid>
      <description>效果 代码实现 #import &amp;quot;ViewController.h&amp;quot; @interface ViewController ()&amp;lt;UITableViewDelegate,UITableViewDataSource&amp;gt; //全局tableView @property (nonatomic,strong)UITableView *tableView; //全局滚动按钮 @property (nonatomic,strong)UIButton *btnTop; @end @implementation ViewController - (void)viewDidLoad { [superviewDidLoad]; //添加tableView [self.viewaddSubview:self.tableView]; //添加滚动按钮 [selfscrollTopView]; } #pragma mark - 设置tableView - (UITableView *)tableView{ if (!_tableView) { _tableView = [[UITableViewalloc]init]; _tableView.frame =CGRectMake(0,64,self.view.frame.size.width , self.view.frame.size.height); _tableView.backgroundColor = [UIColorlightGrayColor]; _tableView.delegate =self; _tableView.dataSource =self; _tableView.separatorStyle =UITableViewCellSeparatorStyleSingleLine; } return_tableView; } #pragma mark - tableView 数据源- //共多少组 -(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{ return 1; } //每组有多少行 -(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{ return 100; } //每行显示的内容 -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ //创建标识符 staticNSString *cellId =@&amp;quot;cellid&amp;quot;; UITableViewCell *cell = [tableViewdequeueReusableCellWithIdentifier:cellId]; //缓存池 if (!</description>
    </item>
    
    <item>
      <title>核心动画 图片抖动</title>
      <link>http://wangerk.com/blog-cn/2017/06/03/pic-shake-keyanimation/</link>
      <pubDate>Sat, 03 Jun 2017 19:07:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/06/03/pic-shake-keyanimation/</guid>
      <description>#import &amp;quot;SHViewController.h&amp;quot; #define ANGLE_TO_RADIAN(angle) ((angle)/180.0 * M_PI) @interface SHViewController () //图标 @property (weak,nonatomic)IBOutletUIImageView *iconView; //开点按钮 - (IBAction)start; //结束按钮 - (IBAction)end; @end @implementation CZViewController - (void)viewDidLoad{ [superviewDidLoad]; } //开点按钮功能呢 - (IBAction)start { //实例化 CAKeyframeAnimation *anim = [CAKeyframeAnimationanimation]; //拿到动画 key anim.keyPath =@&amp;quot;transform.rotation&amp;quot;; // 动画时间 anim.duration =.25; // 重复的次数 //anim.repeatCount = 16; //无限次重复 anim.repeatCount =MAXFLOAT; //设置抖动数值 anim.values =@[@(ANGLE_TO_RADIAN(-5)),@(ANGLE_TO_RADIAN(5)),@(ANGLE_TO_RADIAN(-5))]; // 保持最后的状态 anim.removedOnCompletion =NO; //动画的填充模式 anim.fillMode =kCAFillModeForwards; //layer层实现动画 [self.iconView.layeraddAnimation:animforKey:@&amp;quot;shake&amp;quot;]; } //点击结束按钮 - (IBAction)end { //图标 [self.</description>
    </item>
    
    <item>
      <title>UITableView常用方法合集</title>
      <link>http://wangerk.com/blog-cn/2017/06/02/uitableview/</link>
      <pubDate>Fri, 02 Jun 2017 07:57:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/06/02/uitableview/</guid>
      <description>实现代理三部曲:
一:遵守代理
二:把 tableView.delegate = self
三:实现代理方法
 代理实现 - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; [self.view addSubview:self.tableView]; } #pragma mark - getter/setter - (UITableView *)tableView { if (!_tableView) { _tableView =[[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStyleGrouped]; _tableView.backgroundColor = RGB(239, 239, 239); _tableView.showsVerticalScrollIndicator = NO; _tableView.showsHorizontalScrollIndicator = NO; _tableView.delegate = self; _tableView.dataSource = self; //分割线颜色 _tableView.separatorStyle = UITableViewCellSeparatorStyleNone; } return _tableView; } ************ UITableView 方法 ************ //多少组 -(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{ return 6; } //多少行 -(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{ NSArray *arr = [dic objectForKey:[dic.</description>
    </item>
    
    <item>
      <title>GCD定时器实现获取验证码的倒计时</title>
      <link>http://wangerk.com/blog-cn/2017/06/01/gcd-timer/</link>
      <pubDate>Thu, 01 Jun 2017 08:03:04 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/06/01/gcd-timer/</guid>
      <description>//倒计时按钮 @property(nonatomic,strong)UIButton *btnCountdown; //用 GCD实现倒计时功能 - (void)btnCountdownClick{ //倒计时默认状体 [_btnCountdown setTitle:@&amp;quot;重发(60s)&amp;quot; forState:UIControlStateNormal]; //倒计时时间 __block int timeout=59; //倒计时全局队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //设置一个事件处理器 dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue); //设置时间处理器时间 dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行 dispatch_source_set_event_handler(_timer, ^{ if(timeout&amp;lt;=0){ //倒计时结束，关闭 //取消事件处理器 dispatch_source_cancel(_timer); //回到主线程 dispatch_async(dispatch_get_main_queue(), ^{ //设置界面的按钮显示 根据自己需求设置 _btnCountdown.userInteractionEnabled = YES; //设置倒计时标题 [_btnCountdown setTitle:@&amp;quot;获取验证码&amp;quot; forState:UIControlStateNormal]; }); }else{ //去时间余 int seconds = timeout % 60; //拿到时间文字 NSString *strTime = [NSString stringWithFormat:@&amp;quot;%.2d&amp;quot;, seconds]; //回到主线程 dispatch_async(dispatch_get_main_queue(), ^{ //设置界面的按钮显示 根据自己需求设置 [UIView beginAnimations:nil context:nil]; //设置动画时间为1秒 [UIView setAnimationDuration:1]; //时间倒计时为0的时候显示重发?</description>
    </item>
    
    <item>
      <title>监控联网状态</title>
      <link>http://wangerk.com/blog-cn/2017/05/31/reachability/</link>
      <pubDate>Wed, 31 May 2017 23:56:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/05/31/reachability/</guid>
      <description>AFN监控联网状态
AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager]; // 提示：要监控网络连接状态，必须要先调用单例的startMonitoring方法 [manager startMonitoring]; [manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) { NSLog(@&amp;quot;%d&amp;quot;, status); }];  Reachability监控联网状态苹果提供,导入这两个类使用
// 1.检测wifi状态 Reachability *wifi = [Reachability reachabilityForLocalWiFi]; // 2.检测手机是否能上网络(WIFI\3G\2.5G) Reachability *conn = [Reachability reachabilityForInternetConnection]; // 3.判断网络状态 if ([wifi currentReachabilityStatus] != NotReachable) { // 有wifi NSLog(@&amp;quot;有wifi&amp;quot;); } else if ([conn currentReachabilityStatus] != NotReachable) { // 没有使用wifi, 使用手机自带网络进行上网 NSLog(@&amp;quot;使用手机自带网络进行上网&amp;quot;); } else { // 没有网络 NSLog(@&amp;quot;没有网络&amp;quot;); }  ①判断联网状态
// 用WIFI // [wifi currentReachabilityStatus] !</description>
    </item>
    
    <item>
      <title>GCD信号量线程同步</title>
      <link>http://wangerk.com/blog-cn/2017/05/31/dispatch_semaphore/</link>
      <pubDate>Wed, 31 May 2017 23:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/05/31/dispatch_semaphore/</guid>
      <description>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是  dispatch_semaphore_create， dispatch_semaphore_signal， dispatch_semaphore_wait。  下面我们逐一介绍三个函数：  dispatch_semaphore_create函数的声明为：
dispatch_samaphore_t dispatch_semaphore_create(long value); 传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。 值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。  （关于信号量，我就不在这里累述了，网上很多介绍这个的。我们这里主要讲一下dispatch_semaphore这三个函数的用法）。
 dispatch_semaphore_signal的声明为：
 long dispatch_semaphore_signal(dispatch_semaphore_t dsema)  dispatch_semaphore_wait的声明为
long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)； 这个函数会使传入的信号量dsema的值减1； 这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1； 如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t， 不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了， 且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。 如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。  dispatch_semaphore_signal的返回值为long类型
当返回值为0时表示当前并没有线程等待其处理的信号量，其处理 的信号量的值加1即可。当返回值不为0时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程（当线程有优先级时，唤醒优先级最高的线程；否则随机唤醒）。
dispatch_semaphore_wait的返回值也为long型。
当其返回0时表示在timeout之前，该函数所处的线程被成功唤醒。
当其返回不为0时，表示timeout发生。
 在设置timeout时，比较有用的两个宏：DISPATCH_TIME_NOW 和 DISPATCH_TIME_FOREVER。
DISPATCH_TIME_NOW　表示当前； DISPATCH_TIME_FOREVER　表示遥远的未来；  一般可以直接设置timeout为这两个宏其中的一个，或者自己创建一个dispatch_time_t类型的变量。 创建dispatch_time_t类型的变量有两种方法，dispatch_time和dispatch_walltime。 利用创建dispatch_time创建dispatch_time_t类型变量的时候一般也会用到这两个变量。 dispatch_time的声明如下： dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)； 其参数when需传入一个dispatch_time_t类型的变量，和一个delta值。表示when加delta时间就是timeout的时间。 例如：dispatch_time_t t = dispatch_time(DISPATCH_TIME_NOW, 110001000*1000); 表示当前时间向后延时一秒为timeout的时间。
 关于信号量，一般可以用停车来比喻。</description>
    </item>
    
    <item>
      <title>多线程(GCD)合成图片~demo</title>
      <link>http://wangerk.com/blog-cn/2017/05/31/gcd-join-images/</link>
      <pubDate>Wed, 31 May 2017 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/05/31/gcd-join-images/</guid>
      <description> 图片合成效果 //创建队列组 dispatch_group_tgroup =dispatch_group_create(); //1.开子线程下载图片 //创建队列(并发) dispatch_queue_tqueue =dispatch_get_global_queue(0,0); //异步执行并发队列 dispatch_group_async(group, queue, ^{ //1.获取url地址 NSURL*url = [NSURL URLWithString:@&amp;quot;https://imgsa.baidu.com/baike/c0=baike180,5,5,180,60/sign=b531c24482025aafc73f76999a84c001/b21c8701a18b87d6435d2f9b070828381f30fd13.jpg&amp;quot;]; //2.下载图片 NSData *data = [NSData dataWithContentsOfURL:url]; //3.把二进制数据转换成图片 self.image1= [UIImage imageWithData:data]; }); //下载图片2 dispatch_group_async(group, queue, ^{ //1.获取url地址 NSURL*url = [NSURL URLWithString:@&amp;quot;https://imgsa.baidu.com/baike/c0=baike220,5,5,220,73/sign=62c273b38a13632701e0ca61f0e6cb89/8644ebf81a4c510faae40d756059252dd42aa5b9.jpg&amp;quot;]; //2.下载图片 NSData*data = [NSData dataWithContentsOfURL:url]; //3.把二进制数据转换成图片 self.image2= [UIImage imageWithData:data]; }); //合成 dispatch_group_notify(group, queue, ^{ //开启图形上下文 UIGraphicsBeginImageContext(CGSizeMake(200,200)); //画1 [self.image1 drawInRect:CGRectMake(0,0,200,100)]; //画2 [self.image2 drawInRect:CGRectMake(0,100,200,100)]; //根据图形上下文拿到图片 UIImage*image =UIGraphicsGetImageFromCurrentImageContext(); //关闭上下文 UIGraphicsEndImageContext(); dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image= image; }); });  </description>
    </item>
    
    <item>
      <title>自动适应UILabel的宽度~demo</title>
      <link>http://wangerk.com/blog-cn/2017/05/30/uilable-adjust-width/</link>
      <pubDate>Mon, 30 May 2016 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2017/05/30/uilable-adjust-width/</guid>
      <description>#import &amp;quot;UILabel+Extension.h&amp;quot; - (void)viewDidLoad { [super viewDidLoad]; //直接引用分类功能 [UILabel createLabelWithContent:@&amp;quot;10011111111110&amp;quot; addView:self.view lableX:10 lableY:111 lableH:30 fontSize:16 backgroundColor:[UIColor redColor] textColor:[UIColor blueColor] borderColor:[UIColor yellowColor]]; } + (instancetype)createLabelWithContent:(NSString *)content addView:(UIView *)view lableX:(CGFloat)lableX lableY:(CGFloat)lableY lableH:(CGFloat)lableH fontSize:(CGFloat)fontSize backgroundColor:(UIColor *)backgroundColor textColor:(UIColor*)textColor borderColor:(UIColor *)borderColor{ NSString *string = [NSString stringWithFormat:@&amp;quot;%@&amp;quot;,content]; CGRect textRect = [self boundingString:string size:CGSizeMake([UIScreenmainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height *2) fontSize:fontSize]; CGFloat rowWidth = 0.0; if (string.length == 1) { rowWidth = textRect.size.width + 35; }else{ rowWidth = textRect.size.width + 25; } UILabel *lable = [[UILabel alloc]initWithFrame:CGRectMake(lableX, lableY, rowWidth, lableH)]; lable.</description>
    </item>
    
    <item>
      <title>点击view退出键盘</title>
      <link>http://wangerk.com/blog-cn/2016/04/15/resign-keyboard/</link>
      <pubDate>Fri, 15 Apr 2016 20:55:53 +0800</pubDate>
      
      <guid>http://wangerk.com/blog-cn/2016/04/15/resign-keyboard/</guid>
      <description>//创建 UITapGestureRecognizer *tapGest = [[UITapGestureRecognizer alloc]init]; //监听 [tapGest addTarget:self action:@selector(tapAction)]; [self.view addGestureRecognizer:tapGest]; //退出键盘 - (void)tapAction { //放弃第一响应者resignFirstResponder [self.text resignFirstResponder]; }  </description>
    </item>
    
  </channel>
</rss>